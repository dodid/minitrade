{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#minitrade-simplifying-personal-trading","title":"Minitrade - Simplifying Personal Trading","text":"<p>Minitrade is a personal trading system that combines strategy backtesting and automated order execution. Leveraging the power of Backtesting.py, Minitrade offers an array of enhanced features:</p> <ul> <li>Multi-asset rebalance strategy backtest: Explore and optimize your trading strategies across various assets.</li> <li>Automated strategy execution and order submission: Seamlessly execute your trading strategies and submit orders automatically.</li> <li>Web-based management UI: Access a user-friendly web interface to manage and monitor your trading activities.</li> <li>Streamlined mobile notifications and control: Stay informed and in control with mobile notifications for important trading events.</li> </ul> <p>With Minitrade, setting up your private and fully automated stock trading system is easy and affordable.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install minitrade\n$ minitrade init\n</code></pre> <p>Minitrade requires <code>python &gt;= 3.10</code>. Rerun <code>\"minitrade init\"</code> after every Minitrade upgrade. For detailed installation instructions, refer to the Installation section on the website.</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#backtesting","title":"Backtesting","text":""},{"location":"#trading","title":"Trading","text":"<p>See more in Documentation.</p>"},{"location":"#limitations","title":"Limitations","text":"<p>Please be aware of the following limitations:</p> <ul> <li>Multi-asset strategies currently support long positions and market orders only.</li> <li>Linux and Mac platforms are currently supported.</li> <li>Daily bar data is currently supported.</li> <li>Interactive Brokers is the supported broker.</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Check out the guidelines on how to contribute to the project.</p>"},{"location":"#license","title":"License","text":"<p>AGPL-3.0</p>"},{"location":"api_backtest/","title":"minitrade.backtest","text":""},{"location":"api_backtest/#minitrade.backtest.core.backtesting","title":"minitrade.backtest.core.backtesting","text":"<p>Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.</p> <pre><code>from minitrade.backtest import Backtest, Strategy\n</code></pre>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation","title":"Allocation","text":"<pre><code>Allocation(tickers: list)\n</code></pre> <p>The <code>Allocation</code> class manages the allocation of values among different assets in a portfolio. It provides  methods for creating and managing asset buckets, assigning weights to assets, and merging the weights into the  parent allocation object.</p> <p><code>Allocation</code> is not meant to be instantiated directly. Instead, it is created automatically when a new <code>Strategy</code> object is created. The <code>Allocation</code> object is accessed through the <code>Strategy.alloc</code> property.</p> <p>The <code>Allocation</code> object is used as an input to the <code>Strategy.rebalance()</code> method to rebalance the portfolio according to the current weight allocation.</p> <p><code>Allocation</code> has the following notable properties:</p> <ul> <li><code>tickers</code>: A list of tickers representing the asset space in the allocation.</li> <li><code>weights</code>: The weight allocation to be used in the current rebalance cycle.</li> <li><code>previous_weights</code>: The weight allocation used in the previous rebalance cycle.</li> <li><code>unallocated</code>: Unallocated equity weight, i.e. 1 minus the sum of weights already allocated to assets.</li> <li><code>bucket</code>: Bucket accessor for weight allocation.</li> </ul> <p><code>Allocation</code> provides two ways to assign weights to assets:</p> <ol> <li> <p>Explicitly assign weights to assets using <code>Allocation.weights</code> property. </p> <p>It's possible to assign weights to individual asset or to all assets in the asset space as a whole. Not all weights  need to be specified. If an asset is not assigned a weight, it will have a weight of 0.</p> <p>Example: <pre><code># Assign weight to individual asset\nstrategy.alloc.weights['A'] = 0.5\n\n# Assign weight to all assets\nstrategy.alloc.weights = pd.Series([0.1, 0.2, 0.3], index=['A', 'B', 'C'])\n</code></pre></p> </li> <li> <p>Use <code>Bucket</code> to assign weights to logical groups of assets, then merge the weights into the parent allocation object.</p> <p>A <code>Bucket</code> is a container that groups assets together and provieds methods for weight allocation. Assets can be added to the bucket by appending lists or filtering conditions. Weights can be assigned to the assets in the bucket using different allocation methods. Multiple buckets can be created for different groups of assets. Once the weight  allocation is done at bucket level , the weights of the buckets can be merged into those of the parent allocation object.</p> <p>Example: <pre><code># Create a bucket and add assets to it\nbucket = strategy.alloc.bucket['bucket1']\nbucket.append(['A', 'B', 'C'])\n\n# Assign weights to the assets in the bucket\nbucket.weight_explicitly([0.1, 0.2, 0.3])\n\n# Merge the bucket into the parent allocation object\nbucket.apply('update')\n</code></pre></p> </li> </ol> <p>The state of the <code>Allocation</code> object is managed by the <code>Strategy</code> object across rebalance cycles. A rebalance cycle involves:</p> <ol> <li>Initializing the weight allocation at the beginning of the cycle by calling either <code>Allocation.assume_zero()</code>  to reset all weights to zero or <code>Allocation.assume_previous()</code> to inherit the weights from the previous cycle. This must be done before any weight allocation attempts.</li> <li>Adjusting the weight allocation using either explicitly assignment or <code>Bucket</code> method.</li> <li>Calling <code>Strategy.rebalance()</code> to rebalance the portfolio according to the current allocation plan.</li> </ol> <p>After each rebalance cycle, the weight allocation is reset, and the process starts over. At any point, the weight allocation from the previous cycle can be accessed using the <code>previous_weights</code> property. </p> <p>A rebalance cycle is not necessarily equal to the simulation time step. For example, simulation can be done at  daily frequency, while the portfolio is rebalanced every month. In this case, the weight allocation is maintained  across multiple time steps until the next time <code>Strategy.rebalance()</code> is called.</p> <p>Example: <pre><code>class MyStrategy(Strategy):\n    def init(self):\n        pass\n\n    def next(self):\n        # Initialize the weight allocation\n        self.alloc.assume_zero()\n\n        # Adjust the weight allocation\n        self.alloc.bucket['equity'].append(['A', 'B', 'C']).weight_equally(sum_=0.4).apply('update')\n        self.alloc.bucket['bond'].append(['D', 'E']).weight_equally(sum=_0.4).apply('update')\n        self.alloc.weights['gold'] = self.alloc.unallocated\n\n        # Rebalance the portfolio\n        self.rebalance()\n</code></pre></p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation.bucket","title":"bucket  <code>property</code>","text":"<pre><code>bucket: BucketGroup\n</code></pre> <p><code>bucket</code> provides access to a dictionary of buckets.</p> <p>A bucket can be accessed with a string key. If the bucket does not exist, one will be created automatically.</p> <p>Buckets are cleared after each rebalance cycle.</p> <p>Example: <pre><code># Access the bucket named 'equity'\nbucket = strategy.alloc.bucket['equity']\n</code></pre></p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation.modified","title":"modified  <code>property</code>","text":"<pre><code>modified\n</code></pre> <p>True if weight allocation is changed from previous values.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation.previous_weights","title":"previous_weights  <code>property</code>","text":"<pre><code>previous_weights: Series\n</code></pre> <p>Previous weight allocation. This is a read-only property.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation.tickers","title":"tickers  <code>property</code>","text":"<pre><code>tickers: list\n</code></pre> <p>Assets representing the asset space. This is a read-only property</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation.unallocated","title":"unallocated  <code>property</code>","text":"<pre><code>unallocated: float\n</code></pre> <p>Unallocated equity weight. It's the remaining weight that can be allocated to assets. This is a read-only property.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation.weights","title":"weights  <code>property</code> <code>writable</code>","text":"<pre><code>weights: Series\n</code></pre> <p>Current weight allocation. Weight should be non-negative and the total weight should be less than or equal to 1.</p> <p>It's possible to assign weights to individual asset or to all assets in the asset space as a whole. When assigning weights as a whole, only non-zero weights need to be specified, and other weights are assigned zero automatically.</p> <p>Example: <pre><code># Assign weight to individual asset\nstrategy.alloc.weights['A'] = 0.5\n\n# Assign weight to all assets\nstrategy.alloc.weights = pd.Series([0.1, 0.2, 0.3], index=['A', 'B', 'C'])\n</code></pre></p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation.Bucket","title":"Bucket","text":"<pre><code>Bucket(alloc: Allocation)\n</code></pre> <p><code>Bucket</code> is a container that groups assets together and applies weight allocation among them. A bucket is associated with a parent allocation object, while the allocation object can be associated with multiple buckets.</p> <p>Assets in a bucket are identified by their tickers. They are unique within the bucket, but can be repeated in different buckets. </p> <p>Using <code>Bucket</code> for weight allocation takes 3 steps: </p> <ol> <li>Assets are added to the bucket by appending lists or filtering conditions. The rank of the assets  in the bucket is preserved and can be used to assign weights. </li> <li>Weights are assigned to the assets using different allocation methods. </li> <li>Once the weight allocation at bucket level is done, the weights of the bucket can be merged into  those of the parent allocation object.</li> </ol>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation.Bucket.tickers","title":"tickers  <code>property</code>","text":"<pre><code>tickers: list\n</code></pre> <p>Assets in the bucket. This is a read-only property.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation.Bucket.weights","title":"weights  <code>property</code>","text":"<pre><code>weights: Series\n</code></pre> <p>Weights of the assets in the bucket. This is only available after weight allocation is done by calling <code>Bucket.weight_*()</code> methods. This is a read-only property.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation.Bucket.append","title":"append","text":"<pre><code>append(ranked_list: list | Series, *conditions: list | Series) -&gt; Bucket\n</code></pre> <p>Add assets that are in the ranked list to the end of the bucket.</p> <p><code>ranked_list</code> can be specified in three ways:</p> <ol> <li>A list of assets or anything list-like, all items will be added.</li> <li>A boolean Series with assets as the index and a True value to indicate the asset should be added.</li> <li>A non-boolean Series with assets as the index and all assets in the index will be added.</li> </ol> <p>The rank of the assets is determined by its order in the list or in the index. The rank of the assets  in the bucket is preserved. If an asset is already in the bucket, its rank in bucket will not be affected by appending new list to the bucket, even if the asset is ranked differently in the new list.</p> <p>Multiple conditions can be specified as filters to exclude certain assets in the ranked list from being  added. Assets must satisfy all the conditions in order to be added to the bucket.</p> <p><code>conditions</code> can be specified in the same way as <code>ranked_list</code>, only that the asset order in a condition is not important.</p> <p>Example: <pre><code># Append 'A' and 'B' to the bucket\nbucket.append(['A', 'B'])\n\n# Append 'A' and 'C' to the bucket\nbucket.append(pd.Series([True, False, True], index=['A', 'B', 'C']))\n\n# Append 'C' to the bucket\nbucket.append(pd.Series([1, 2, 3], index=['A', 'B', 'C']).nlargest(2), pd.Series([1, 2, 3], index=['A', 'B', 'C']) &gt; 2)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>ranked_list</code> <code>list | Series</code> <p>A list of assets or a Series of assets to be added to the bucket.</p> required <code>conditions</code> <code>list | Series</code> <p>A list of assets or a Series of assets to be used as conditions to filter the assets.</p> <code>()</code>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation.Bucket.apply","title":"apply","text":"<pre><code>apply(method: str = 'update') -&gt; Bucket\n</code></pre> <p>Apply the weight allocation to the parent allocation object.</p> <p><code>method</code> controls how the bucket weight allocation should be merged into the parent allocation object.</p> <p>When <code>method</code> is <code>update</code>, the weights of assets in the bucket will update the weights of the same assets in the parent allocation object. If an asset is not in the bucket, its weight in the parent allocation object  will not be changed. This is the default method.</p> <p>When <code>method</code> is <code>overwrite</code>, the weights of the parent allocation object will be replaced by the weights of the  assets in the bucket or set to 0 if the asset is not in the bucket.</p> <p>When <code>method</code> is <code>accumulate</code>, the weights of the assets in the bucket will be added to the weights of the same  assets, while the weights of the assets not in the bucket will remain unchanged.</p> <p>If the bucket is empty, no change will be made to the parent allocation object.</p> <p>Note that no validation is performed on the weights of the parent allocation object after the bucket weight is merged. It is the responsibility of the user to ensure the final weights are valid before use.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Method to merge the bucket into the parent allocation object.  Available methods are 'update', 'overwrite', 'accumulate'.</p> <code>'update'</code>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation.Bucket.remove","title":"remove","text":"<pre><code>remove(*conditions: list | Series) -&gt; Bucket\n</code></pre> <p>Remove assets that satisify all the given conditions from the bucket.</p> <p><code>conditions</code> can be specified in three ways:</p> <ol> <li>A list of assets or anything list-like, all assets will be removed.</li> <li>A boolean Series with assets as the index and a True value to indicate the asset should be removed.</li> <li>A non-boolean Series with assets as the index and all assets in the index will be removed.</li> </ol> <p>Example: <pre><code># Remove 'A' and 'B' from the bucket\nbucket.remove(['A', 'B'])\n\n# Remove 'A' and 'C' from the bucket\nbucket.remove(pd.Series([True, False, True], index=['A', 'B', 'C']))\n\n# Remove 'A' and 'B' from the bucket\nbucket.remove(pd.Series([1, 2, 3], index=['A', 'B', 'C']).nsmallest(2))\n\n# Remove 'B' from the bucket\nbucket.remove(pd.Series([1, 2, 3], index=['A', 'B', 'C']) &gt; 1, pd.Series([1, 2, 3], index=['A', 'B', 'C']) &lt; 3)\n</code></pre> Args:     conditions: A list of assets or a Series of assets to be used as conditions to filter the assets.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation.Bucket.trim","title":"trim","text":"<pre><code>trim(limit: int) -&gt; Bucket\n</code></pre> <p>Trim the bucket to a maximum number of assets.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Maximum number of assets should be included</p> required"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation.Bucket.weight_equally","title":"weight_equally","text":"<pre><code>weight_equally(sum_: float = None) -&gt; Bucket\n</code></pre> <p>Allocate equity value equally to the assets in the bucket.</p> <p><code>sum_</code> should be between 0 and 1, with 1 means 100% of value should be allocated.</p> <p>Example: <pre><code>bucket.append(['A', 'B', 'C']).weight_equally(0.5)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>sum_</code> <code>float</code> <p>Total weight that should be allocated.</p> <code>None</code>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation.Bucket.weight_explicitly","title":"weight_explicitly","text":"<pre><code>weight_explicitly(weight: float | list | Series) -&gt; Bucket\n</code></pre> <p>Assign weights to the assets in the bucket.</p> <p><code>weight</code> can be specified in three ways:</p> <ol> <li>A single weight should be assigned to all assets in the bucket.</li> <li>A list of weights should be assigned to the assets in the bucket in rank order. If more weights are provided than the number of assets in the bucket, the extra weights are ignored. If fewer weights are provided, the remaining assets will be assigned a weight of 0.</li> <li>A Series with assets as the index and the weight as the value. If no weight is provided for an asset, it will be assigned a weight of 0. If a weight is provided for an asset that is not in the bucket, it will be ignored.</li> </ol> <p>Example: <pre><code>bucket.append(['A', 'B', 'C']).weight_explicitly(0.2)\nbucket.append(['A', 'B', 'C']).weight_explicitly([0.1, 0.2, 0.3])\nbucket.append(['A', 'B', 'C']).weight_explicitly(pd.Series([0.1, 0.2, 0.3], index=['A', 'B', 'C']))\n</code></pre> Args:     weight: A single value, a list of values or a Series of weights.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation.Bucket.weight_proportionally","title":"weight_proportionally","text":"<pre><code>weight_proportionally(relative_weights: list, sum_: float = None) -&gt; Bucket\n</code></pre> <p>Allocate equity value proportionally to the assets in the bucket.</p> <p><code>sum_</code> should be between 0 and 1, with 1 means 100% of value should be allocated.</p> <p>Example: <pre><code>bucket.append(['A', 'B', 'C']).weight_proportionally([1, 2, 3], 0.5)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>relative_weights</code> <code>list</code> <p>A list of relative weights. The length of the list should be the same as the number of assets in the bucket.</p> required <code>sum_</code> <code>float</code> <p>Total weight that should be allocated.</p> <code>None</code>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation.assume_previous","title":"assume_previous","text":"<pre><code>assume_previous()\n</code></pre> <p>Assume all assets inherit the same weight as used in the previous rebalance cycle.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation.assume_zero","title":"assume_zero","text":"<pre><code>assume_zero()\n</code></pre> <p>Assume all assets have zero weight to begin with in a new rebalance cycle.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Allocation.normalize","title":"normalize","text":"<pre><code>normalize()\n</code></pre> <p>Normalize the weight allocation so that the sum of weights equals 1.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Backtest","title":"Backtest","text":"<pre><code>Backtest(data: DataFrame, strategy: Type[Strategy], *, cash: float = 10000, holding: dict = {}, commission: float = 0.0, margin: float = 1.0, trade_on_close=False, hedging=False, exclusive_orders=False, trade_start_date=None, lot_size=1, fail_fast=True, storage: dict | None = None)\n</code></pre> <p>Backtest a particular (parameterized) strategy on particular data.</p> <p>Upon initialization, call method <code>minitrade.backtest.core.backtesting.Backtest.run</code> to run a backtest instance, or <code>minitrade.backtest.core.backtesting.Backtest.optimize</code> to optimize it.</p> <p><code>data</code> is a <code>pd.DataFrame</code> with 2-level columns: 1st level is a list of tickers, and  2nd level is <code>Open</code>, <code>High</code>, <code>Low</code>, <code>Close</code>, and <code>Volume</code>. If the strategy works only on one asset, the 1st level can be dropped. If any columns are missing, set them to what you have available, e.g.</p> <pre><code>df['Open'] = df['High'] = df['Low'] = df['Close']\ndf['Volumn'] = 0\n</code></pre> <p>The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).</p> <p><code>strategy</code> is a <code>minitrade.backtest.core.backtesting.Strategy</code> subclass (not an instance).</p> <p><code>cash</code> is the initial cash to start with.</p> <p><code>holding</code> is a mapping of preexisting assets and their sizes before  backtest begins, e.g. </p> <pre><code>{'AAPL': 10, 'MSFT': 5}\n</code></pre> <p><code>commission</code> is the commission ratio. E.g. if your broker's commission is 1% of trade value, set commission to <code>0.01</code>. Note, if you wish to account for bid-ask spread, you can approximate doing so by increasing the commission, e.g. set it to <code>0.0002</code> for commission-less forex trading where the average spread is roughly 0.2\u2030 of asking price.</p> <p><code>margin</code> is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to <code>0.02</code> (1 / leverage).</p> <p>If <code>trade_on_close</code> is <code>True</code>, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.</p> <p>If <code>hedging</code> is <code>True</code>, allow trades in both directions simultaneously. If <code>False</code>, the opposite-facing orders first close existing trades in a FIFO manner.</p> <p>If <code>exclusive_orders</code> is <code>True</code>, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.</p> <p>If <code>trade_start_date</code> is not None, orders generated before the date are surpressed and ignored in backtesting.</p> <p><code>lot_size</code> is the minimum increment of shares you buy in one order. Order  size will be rounded to integer multiples during rebalance.</p> <p><code>fail_fast</code>, when True, instructs the backtester to bail out when cash is not enough to cover an order. This can be used in live trading to detect issues early. If False, backtesting will ignore the order and  continue, which can be convenient during algorithm research.</p> <p><code>storage</code>, when not None, is a dictionary that contains saved states from  past runs. Modification to storage is persisted and can be made available  for future runs. </p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Backtest.optimize","title":"optimize","text":"<pre><code>optimize(*, maximize: Union[str, Callable[[Series], float]] = 'SQN', method: str = 'grid', max_tries: Optional[Union[int, float]] = None, constraint: Optional[Callable[[dict], bool]] = None, return_heatmap: bool = False, return_optimization: bool = False, random_state: Optional[int] = None, **kwargs) -&gt; Union[Series, Tuple[Series, Series], Tuple[Series, Series, dict]]\n</code></pre> <p>Optimize strategy parameters to an optimal combination. Returns result <code>pd.Series</code> of the best run.</p> <p><code>maximize</code> is a string key from the <code>minitrade.backtest.core.backtesting.Backtest.run</code>-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.</p> <p><code>method</code> is the optimization method. Currently two methods are supported:</p> <ul> <li><code>\"grid\"</code> which does an exhaustive (or randomized) search over the   cartesian product of parameter combinations, and</li> <li><code>\"skopt\"</code> which finds close-to-optimal strategy parameters using   model-based optimization, making at most <code>max_tries</code> evaluations.</li> </ul> <p><code>max_tries</code> is the maximal number of strategy runs to perform. If <code>method=\"grid\"</code>, this results in randomized grid search. If <code>max_tries</code> is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for <code>method=\"skopt\"</code>, <code>max_tries</code> is set to 200.</p> <p><code>constraint</code> is a function that accepts a dict-like object of parameters (with values) and returns <code>True</code> when the combination is admissible to test with. By default, any parameters combination is considered admissible.</p> <p>If <code>return_heatmap</code> is <code>True</code>, besides returning the result series, an additional <code>pd.Series</code> is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see <code>backtesting.lib.plot_heatmaps()</code>).</p> <p>If <code>return_optimization</code> is True and <code>method = 'skopt'</code>, in addition to result series (and maybe heatmap), return raw <code>scipy.optimize.OptimizeResult</code> for further inspection, e.g. with scikit-optimize plotting tools.</p> <p>If you want reproducible optimization results, set <code>random_state</code> to a fixed integer random seed.</p> <p>Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the \"best\" of the 7 admissible (of the 9 possible) parameter combinations:</p> <pre><code>backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],\n                  constraint=lambda p: p.sma1 &lt; p.sma2)\n</code></pre> <p>.. TODO::     Improve multiprocessing/parallel execution on Windos with start method 'spawn'.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Backtest.plot","title":"plot","text":"<pre><code>plot(*, results: Series = None, filename=None, plot_width=None, plot_equity=True, plot_return=False, plot_pl=True, plot_volume=False, plot_drawdown=False, plot_trades=True, smooth_equity=False, relative_equity=True, superimpose: Union[bool, str] = False, resample=True, reverse_indicators=False, show_legend=True, open_browser=True, plot_allocation=False, relative_allocation=True, plot_indicator=True)\n</code></pre> <p>Plot the progression of the last backtest run.</p> <p>If <code>results</code> is provided, it should be a particular result <code>pd.Series</code> such as returned by <code>minitrade.backtest.core.backtesting.Backtest.run</code> or <code>minitrade.backtest.core.backtesting.Backtest.optimize</code>, otherwise the last run's results are used.</p> <p><code>filename</code> is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.</p> <p><code>plot_width</code> is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.</p> <p>If <code>plot_equity</code> is <code>True</code>, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as <code>plot_return</code> plus initial 100%.</p> <p>If <code>plot_return</code> is <code>True</code>, the resulting plot will contain a cumulative return graph section. This is the same as <code>plot_equity</code> minus initial 100%.</p> <p>If <code>plot_pl</code> is <code>True</code>, the resulting plot will contain a profit/loss (P/L) indicator section.</p> <p>If <code>plot_volume</code> is <code>True</code>, the resulting plot will contain a trade volume section.</p> <p>If <code>plot_drawdown</code> is <code>True</code>, the resulting plot will contain a separate drawdown graph section.</p> <p>If <code>plot_trades</code> is <code>True</code>, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.</p> <p>If <code>smooth_equity</code> is <code>True</code>, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.</p> <p>If <code>relative_equity</code> is <code>True</code>, scale and label equity graph axis with return percent, not absolute cash-equivalent values.</p> <p>If <code>superimpose</code> is <code>True</code>, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. <code>superimpose</code> can also be a valid Pandas offset string, such as <code>'5T'</code> or <code>'5min'</code>, in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.</p> <p>If <code>resample</code> is <code>True</code>, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's <code>Javascript Error: Maximum call stack size exceeded</code> or similar. Equity &amp; dropdown curves and individual trades data is, <code>resample</code> can also be a Pandas offset string, such as <code>'5T'</code> or <code>'5min'</code>, in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.</p> <p>If <code>reverse_indicators</code> is <code>True</code>, the indicators below the OHLC chart are plotted in reverse order of declaration.</p> <p>If <code>show_legend</code> is <code>True</code>, the resulting plot graphs will contain labeled legends.</p> <p>If <code>open_browser</code> is <code>True</code>, the resulting <code>filename</code> will be opened in the default web browser.</p> <p>If <code>plot_allocation</code> is <code>True</code>, the resulting plot will contain an equity allocation graph section. </p> <p>If <code>relative_allocation</code> is <code>True</code>, scale and label equity allocation graph axis with return percent, not absolute cash-equivalent values.</p> <p>If <code>plot_indicator</code> is <code>True</code>, the resulting plot will contain a section for each indicator used in the strategy.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Backtest.run","title":"run","text":"<pre><code>run(**kwargs) -&gt; Series\n</code></pre> <p>Run the backtest. Returns <code>pd.Series</code> with results and statistics.</p> <p>Keyword arguments are interpreted as strategy parameters.</p> <pre><code>&gt;&gt;&gt; Backtest(GOOG, SmaCross).run()\nStart                     2004-08-19 00:00:00\nEnd                       2013-03-01 00:00:00\nDuration                   3116 days 00:00:00\nExposure Time [%]                     93.9944\nEquity Final [$]                      51959.9\nEquity Peak [$]                       75787.4\nReturn [%]                            419.599\nBuy &amp; Hold Return [%]                 703.458\nReturn (Ann.) [%]                      21.328\nVolatility (Ann.) [%]                 36.5383\nSharpe Ratio                         0.583718\nSortino Ratio                         1.09239\nCalmar Ratio                         0.444518\nMax. Drawdown [%]                    -47.9801\nAvg. Drawdown [%]                    -5.92585\nMax. Drawdown Duration      584 days 00:00:00\nAvg. Drawdown Duration       41 days 00:00:00\n# Trades                                   65\nWin Rate [%]                          46.1538\nBest Trade [%]                         53.596\nWorst Trade [%]                      -18.3989\nAvg. Trade [%]                        2.35371\nMax. Trade Duration         183 days 00:00:00\nAvg. Trade Duration          46 days 00:00:00\nProfit Factor                         2.08802\nExpectancy [%]                        8.79171\nSQN                                  0.916893\nKelly Criterion                        0.6134\n_strategy                            SmaCross\n_equity_curve                           Eq...\n_trades                       Size  EntryB...\n_orders                              Ticke...\n_positions                           {'GOO...\n_trade_start_bar                           0\ndtype: object\n</code></pre> <p>.. warning::     You may obtain different results for different strategy parameters.     E.g. if you use 50- and 200-bar SMA, the trading simulation will     begin on bar 201. The actual length of delay is equal to the lookback     period of the <code>Strategy.I</code> indicator which lags the most.     Obviously, this can affect results.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Order","title":"Order","text":"<pre><code>Order(broker: _Broker, ticker: str, size: float, limit_price: Optional[float] = None, stop_price: Optional[float] = None, sl_price: Optional[float] = None, tp_price: Optional[float] = None, parent_trade: Optional[Trade] = None, entry_time: datetime = None, tag: object = None)\n</code></pre> <p>Place new orders through <code>Strategy.buy()</code> and <code>Strategy.sell()</code>. Query existing orders through <code>Strategy.orders</code>.</p> <p>When an order is executed or filled, it results in a <code>Trade</code>.</p> <p>If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.</p> <p>All placed orders are Good 'Til Canceled.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Order.entry_time","title":"entry_time  <code>property</code>","text":"<pre><code>entry_time: datetime\n</code></pre> <p>Time of when the order is created.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Order.is_contingent","title":"is_contingent  <code>property</code>","text":"<pre><code>is_contingent\n</code></pre> <p>True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent <code>Trade</code> is closed.</p> <p>You can modify contingent orders through <code>Trade.sl</code> and <code>Trade.tp</code>.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Order.is_long","title":"is_long  <code>property</code>","text":"<pre><code>is_long\n</code></pre> <p>True if the order is long (order size is positive).</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Order.is_short","title":"is_short  <code>property</code>","text":"<pre><code>is_short\n</code></pre> <p>True if the order is short (order size is negative).</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Order.limit","title":"limit  <code>property</code>","text":"<pre><code>limit: Optional[float]\n</code></pre> <p>Order limit price for limit orders, or None for market orders, which are filled at next available price.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Order.size","title":"size  <code>property</code> <code>writable</code>","text":"<pre><code>size: float\n</code></pre> <p>Order size (negative for short orders).</p> <p>If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus <code>Position.pl</code> minus used margin). A value greater than or equal to 1 indicates an absolute number of units.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Order.sl","title":"sl  <code>property</code>","text":"<pre><code>sl: Optional[float]\n</code></pre> <p>A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the <code>Trade</code> following this order's execution. See also <code>Trade.sl</code>.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Order.stop","title":"stop  <code>property</code>","text":"<pre><code>stop: Optional[float]\n</code></pre> <p>Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Order.tag","title":"tag  <code>property</code>","text":"<pre><code>tag\n</code></pre> <p>Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated <code>Trade</code> (see <code>Trade.tag</code>).</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Order.tp","title":"tp  <code>property</code>","text":"<pre><code>tp: Optional[float]\n</code></pre> <p>A take-profit price at which, if set, a new contingent limit order will be placed upon the <code>Trade</code> following this order's execution. See also <code>Trade.tp</code>.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Order.cancel","title":"cancel","text":"<pre><code>cancel()\n</code></pre> <p>Cancel the order.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Position","title":"Position","text":"<pre><code>Position(broker: _Broker, ticker: str)\n</code></pre> <p>Currently held asset position, available as <code>minitrade.backtest.core.backtesting.Strategy.position</code> within <code>minitrade.backtest.core.backtesting.Strategy.next</code>. Can be used in boolean contexts, e.g.</p> <pre><code>if self.position():\n    ...  # we have a position, either long or short\n</code></pre>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Position.is_long","title":"is_long  <code>property</code>","text":"<pre><code>is_long: bool\n</code></pre> <p>True if the position is long (position size is positive).</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Position.is_short","title":"is_short  <code>property</code>","text":"<pre><code>is_short: bool\n</code></pre> <p>True if the position is short (position size is negative).</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Position.pl","title":"pl  <code>property</code>","text":"<pre><code>pl: float\n</code></pre> <p>Profit (positive) or loss (negative) of the current position in cash units.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Position.pl_pct","title":"pl_pct  <code>property</code>","text":"<pre><code>pl_pct: float\n</code></pre> <p>Profit (positive) or loss (negative) of the current position in percent.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Position.size","title":"size  <code>property</code>","text":"<pre><code>size: float\n</code></pre> <p>Position size in units of asset. Negative if position is short.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Position.close","title":"close","text":"<pre><code>close(portion: float = 1.0)\n</code></pre> <p>Close portion of position by closing <code>portion</code> of each active trade. See <code>Trade.close</code>.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Strategy","title":"Strategy","text":"<pre><code>Strategy(broker, data, params)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>A trading strategy base class. Extend this class and override methods <code>minitrade.backtest.core.backtesting.Strategy.init</code> and <code>minitrade.backtest.core.backtesting.Strategy.next</code> to define your own strategy.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Strategy.alloc","title":"alloc  <code>property</code>","text":"<pre><code>alloc: Allocation\n</code></pre> <p><code>Allocation</code> instance that manages the weight allocation among assets.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Strategy.closed_trades","title":"closed_trades  <code>property</code>","text":"<pre><code>closed_trades: Tuple[Trade, ...]\n</code></pre> <p>List of settled trades (see <code>Trade</code>).</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Strategy.data","title":"data  <code>property</code>","text":"<pre><code>data: _Data\n</code></pre> <p>Price data, roughly as passed into <code>minitrade.backtest.core.backtesting.Backtest.__init__</code>, but with two significant exceptions:</p> <ul> <li><code>data</code> is not a DataFrame, but a custom structure   that serves customized numpy arrays for reasons of performance   and convenience. Besides OHLCV columns, <code>.index</code> and length,   it offers <code>.pip</code> property, the smallest price unit of change.</li> <li>Within <code>minitrade.backtest.core.backtesting.Strategy.init</code>, <code>data</code> arrays   are available in full length, as passed into   <code>minitrade.backtest.core.backtesting.Backtest.__init__</code>   (for precomputing indicators and such). However, within   <code>minitrade.backtest.core.backtesting.Strategy.next</code>, <code>data</code> arrays are   only as long as the current iteration, simulating gradual   price point revelation. In each call of   <code>minitrade.backtest.core.backtesting.Strategy.next</code> (iteratively called by   <code>minitrade.backtest.core.backtesting.Backtest</code> internally),   the last array value (e.g. <code>data.Close[-1]</code>)   is always the most recent value.</li> <li>If you need data arrays (e.g. <code>data.Close</code>) to be indexed   Pandas Series or DataFrame, you can call their <code>.df</code> accessor   (e.g. <code>data.Close.df</code>). If you need the whole of data   as a DataFrame, use <code>.df</code> accessor (i.e. <code>data.df</code>).</li> </ul>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Strategy.equity","title":"equity  <code>property</code>","text":"<pre><code>equity: float\n</code></pre> <p>Current account equity (cash plus assets).</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Strategy.orders","title":"orders  <code>property</code>","text":"<pre><code>orders: List[Order]\n</code></pre> <p>List of orders (see <code>Order</code>) waiting for execution.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Strategy.storage","title":"storage  <code>property</code>","text":"<pre><code>storage: dict | None\n</code></pre> <p>Storage is a dictionary for saving custom data across backtest runs when used in the context of automated trading in incremental mode. </p> <p>If backtest finishes successfully, any modification to the dictionary  is persisted and can be accessed in future runs. If backtest fails due  to any error, the modification is not saved. If backtest runs in dryrun  mode, the modification is not saved.</p> <p>No storage is provided when trading in \"strict\" mode, in which case <code>storage</code>  is None.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Strategy.I","title":"I","text":"<pre><code>I(funcval: Union[DataFrame, Series, Callable], *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs) -&gt; Union[DataFrame, Series]\n</code></pre> <p>Declare an indicator. An indicator is just an array of values, but one that is revealed gradually in <code>minitrade.backtest.core.backtesting.Strategy.next</code> much like <code>minitrade.backtest.core.backtesting.Strategy.data</code> is. Returns DataFrame in <code>init()</code> and <code>np.ndarray</code> of indicator values in <code>next()</code>.</p> <p><code>funcval</code> is either a function that returns the indicator array(s) of same length as <code>minitrade.backtest.core.backtesting.Strategy.data</code>, or the indicator array(s) itself as a DataFrame, Series, or arrays.</p> <p>In the plot legend, the indicator is labeled with function name,  DataFrame column name, or Series name, unless <code>name</code> overrides it.</p> <p>If <code>plot</code> is <code>True</code>, the indicator is plotted on the resulting <code>minitrade.backtest.core.backtesting.Backtest.plot</code>.</p> <p>If <code>overlay</code> is <code>True</code>, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If <code>False</code>, the indicator is plotted standalone below the candlestick chart. </p> <p><code>color</code> can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.</p> <p>If <code>scatter</code> is <code>True</code>, the plotted indicator marker will be a circle instead of a connected line segment (default).</p> <p>Additional <code>*args</code> and <code>**kwargs</code> are passed to <code>func</code> and can be used for parameters.</p> <p>For example, using simple moving average function from TA-Lib:</p> <pre><code>def init():\n    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)\n</code></pre>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Strategy.buy","title":"buy","text":"<pre><code>buy(*, ticker: str = None, size: float = _FULL_EQUITY, limit: Optional[float] = None, stop: Optional[float] = None, sl: Optional[float] = None, tp: Optional[float] = None, tag: object = None)\n</code></pre> <p>Place a new long order. For explanation of parameters, see <code>Order</code> and its properties.</p> <p>For single asset strategy, <code>ticker</code> can be left as None.</p> <p>See <code>Position.close()</code> and <code>Trade.close()</code> for closing existing positions.</p> <p>See also <code>Strategy.sell()</code>.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Strategy.init","title":"init  <code>abstractmethod</code>","text":"<pre><code>init()\n</code></pre> <p>Initialize the strategy. Override this method. Declare indicators (with <code>minitrade.backtest.core.backtesting.Strategy.I</code>). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.</p> <p>If you extend composable strategies from <code>minitrade.backtest.core.backtesting.lib</code>, make sure to call: <code>super().init()</code></p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Strategy.next","title":"next  <code>abstractmethod</code>","text":"<pre><code>next()\n</code></pre> <p>Main strategy runtime method, called as each new <code>minitrade.backtest.core.backtesting.Strategy.data</code> instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in <code>minitrade.backtest.core.backtesting.Strategy.init</code> take place.</p> <p>If you extend composable strategies from <code>minitrade.backtest.core.backtesting.lib</code>, make sure to call: <code>super().next()</code></p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Strategy.position","title":"position","text":"<pre><code>position(ticker: str = None) -&gt; Position\n</code></pre> <p>Instance of <code>minitrade.backtest.core.backtesting.Position</code>.</p> <p>For single asset strategy, <code>ticker</code> can be left as None, which returns the position of the only asset.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Strategy.prepare_data","title":"prepare_data  <code>classmethod</code>","text":"<pre><code>prepare_data(tickers: List[str], start: str) -&gt; DataFrame | None\n</code></pre> <p>Prepare data for trading.</p> <p>This class method can be overridden in a <code>Strategy</code> implementation to provide data for trading. The can be useful when the data is not provided externally and the strategy wants to bring its own data, e.g. from a database.</p> <p>Parameters:</p> Name Type Description Default <code>tickers</code> <code>List[str]</code> <p>List of tickers to fetch data for.</p> required <code>start</code> <code>str</code> <p>Start date of the data to fetch.</p> required <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>A <code>pd.DataFrame</code> with 2-level columns as required by <code>Backtest()</code> or None.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Strategy.rebalance","title":"rebalance","text":"<pre><code>rebalance(force: bool = False, rtol: float = 0.01, atol: int = 0, cash_reserve: float = 0.1)\n</code></pre> <p>Rebalance the portfolio according to the current weight allocation.</p> <p>If the weight allocation is not changed from the previous cycle, the rebalance is skipped. This behavior can be overridden by setting <code>force</code> to <code>True</code>, which will force rebalance even if the weight allocation is unchanged. This is useful when the actual portfolio value deviates from the target value due to price changes and should  be corrected.</p> <p>When a rebalance should be performed, the difference between the target and actual portfolio, defined as the sum  of absolute difference of individual assets, is calculated. If the difference is too small compared to the relative tolerance <code>rtol</code> or the absolute tolerance <code>atol</code>, the rebalance is again skipped. This can be used to avoid unnecessary transaction cost. An exception is when the target weight of an asset is zero, in which case  the position of the asset, if exists, is always closed.</p> <p><code>cash_reserve</code> is the ratio of total equity reserved as cash to account for order quantity rounding and sudden price changes between order placement and execution. It is recommended to set this value to a small positive number to avoid order rejection due to insufficient cash. The minimum value may depend on the volatility of the  assets.</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>bool</code> <p>If True, rebalance will be performed even if the current weight allocation is not changed from the previous.</p> <code>False</code> <code>rtol</code> <code>float</code> <p>Relative tolerance of the total absolute value difference between current  and previous allocation vs. total portfolio value. If the difference is smaller  than <code>rtol</code>, rebalance will not be performed.</p> <code>0.01</code> <code>atol</code> <code>int</code> <p>Absolute tolerance of the total absolute value difference between current  and previous allocation. If the difference is smaller than <code>atol</code>, rebalance  will not be performed.</p> <code>0</code> <code>cash_reserve</code> <code>float</code> <p>Ratio of total equity reserved as cash to account for order  quantity rounding and sudden price changes between order placement and execution.</p> <code>0.1</code>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Strategy.record","title":"record","text":"<pre><code>record(name: str = None, plot: bool = True, overlay: bool = None, color: str = None, scatter: bool = False, **kwargs)\n</code></pre> <p>Record arbitrary key-value pairs as time series. This can be used for diagnostic data collection or for plotting custom data. </p> <p>Values to be recorded should be passed as keyword arguments. The value can be a scalar, a dictionary, or a pandas Series. If a dictionary or a Series is passed, its keys will be used as names for time series.</p> <p>Example: <pre><code># Record a scalar value\nself.record(my_key=42)\n\n# Record a dictionary\nself.record(my_dict={'a': 1, 'b': 2})\n\n# Record a pandas Series\nself.record(my_series=pd.Series({'a': 1, 'b': 2}))\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the time series. If not provided, the name will be the same as the keyword argument.</p> <code>None</code> <code>plot</code> <code>bool</code> <p>If True, the time series will be plotted on the resulting <code>minitrade.backtest.core.backtesting.Backtest.plot</code>.</p> <code>True</code> <code>overlay</code> <code>bool</code> <p>If True, the time series will be plotted overlaying the price candlestick chart. If False, the time series will be plotted standalone below the candlestick chart.</p> <code>None</code> <code>color</code> <code>str</code> <p>Color of the time series. If not provided, the next available color will be assigned.</p> <code>None</code> <code>scatter</code> <code>bool</code> <p>If True, the plotted time series marker will be a circle instead of a connected line segment.</p> <code>False</code>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Strategy.sell","title":"sell","text":"<pre><code>sell(*, ticker: str = None, size: float = _FULL_EQUITY, limit: Optional[float] = None, stop: Optional[float] = None, sl: Optional[float] = None, tp: Optional[float] = None, tag: object = None)\n</code></pre> <p>Place a new short order. For explanation of parameters, see <code>Order</code> and its properties.</p> <p>For single asset strategy, <code>ticker</code> can be left as None.</p> <p>See also <code>Strategy.buy()</code>.</p> <p>.. note::     If you merely want to close an existing long position,     use <code>Position.close()</code> or <code>Trade.close()</code>.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Strategy.start_on_day","title":"start_on_day","text":"<pre><code>start_on_day(n: int)\n</code></pre> <p>Hint to start the backtest on a specific day.</p> <p>This can be used to define a warm-up period, ensuring at least <code>n</code> days of data  are available when <code>next()</code> is called for the first time. </p> <p>When the backtest starts depends both on <code>n</code> and on the availability of indicators.  If indicators are defined, the backtest will start when all indicators have  valid data or on the <code>n</code>-th day, whichever comes later.</p> <p>This method should be called in <code>init()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Day index to start on. Must be within [0, len(data)-1].</p> required"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Strategy.trades","title":"trades","text":"<pre><code>trades(ticker: str = None) -&gt; Tuple[Trade, ...]\n</code></pre> <p>List of active trades (see <code>Trade</code>).</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Trade","title":"Trade","text":"<pre><code>Trade(broker: _Broker, ticker: str, size: int, entry_price: float, entry_bar, tag)\n</code></pre> <p>When an <code>Order</code> is filled, it results in an active <code>Trade</code>. Find active trades in <code>Strategy.trades</code> and closed, settled trades in <code>Strategy.closed_trades</code>.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Trade.entry_bar","title":"entry_bar  <code>property</code>","text":"<pre><code>entry_bar: int\n</code></pre> <p>Candlestick bar index of when the trade was entered.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Trade.entry_price","title":"entry_price  <code>property</code>","text":"<pre><code>entry_price: float\n</code></pre> <p>Trade entry price.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Trade.entry_time","title":"entry_time  <code>property</code>","text":"<pre><code>entry_time: Union[Timestamp, int]\n</code></pre> <p>Datetime of when the trade was entered.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Trade.exit_bar","title":"exit_bar  <code>property</code>","text":"<pre><code>exit_bar: Optional[int]\n</code></pre> <p>Candlestick bar index of when the trade was exited (or None if the trade is still active).</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Trade.exit_price","title":"exit_price  <code>property</code>","text":"<pre><code>exit_price: Optional[float]\n</code></pre> <p>Trade exit price (or None if the trade is still active).</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Trade.exit_time","title":"exit_time  <code>property</code>","text":"<pre><code>exit_time: Optional[Union[Timestamp, int]]\n</code></pre> <p>Datetime of when the trade was exited.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Trade.is_long","title":"is_long  <code>property</code>","text":"<pre><code>is_long\n</code></pre> <p>True if the trade is long (trade size is positive).</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Trade.is_short","title":"is_short  <code>property</code>","text":"<pre><code>is_short\n</code></pre> <p>True if the trade is short (trade size is negative).</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Trade.pl","title":"pl  <code>property</code>","text":"<pre><code>pl\n</code></pre> <p>Trade profit (positive) or loss (negative) in cash units.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Trade.pl_pct","title":"pl_pct  <code>property</code>","text":"<pre><code>pl_pct\n</code></pre> <p>Trade profit (positive) or loss (negative) in percent.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Trade.size","title":"size  <code>property</code>","text":"<pre><code>size\n</code></pre> <p>Trade size (volume; negative for short trades).</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Trade.sl","title":"sl  <code>property</code> <code>writable</code>","text":"<pre><code>sl\n</code></pre> <p>Stop-loss price at which to close the trade.</p> <p>This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it <code>None</code>, you cancel it.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Trade.tag","title":"tag  <code>property</code>","text":"<pre><code>tag\n</code></pre> <p>A tag value inherited from the <code>Order</code> that opened this trade.</p> <p>This can be used to track trades and apply conditional logic / subgroup analysis.</p> <p>See also <code>Order.tag</code>.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Trade.tp","title":"tp  <code>property</code> <code>writable</code>","text":"<pre><code>tp\n</code></pre> <p>Take-profit price at which to close the trade.</p> <p>This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it <code>None</code>, you cancel it.</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Trade.value","title":"value  <code>property</code>","text":"<pre><code>value\n</code></pre> <p>Trade total value in cash (volume \u00d7 price).</p>"},{"location":"api_backtest/#minitrade.backtest.core.backtesting.Trade.close","title":"close","text":"<pre><code>close(portion: float = 1.0, finalize=False)\n</code></pre> <p>Place new <code>Order</code> to close <code>portion</code> of the trade at next market price.</p>"},{"location":"api_broker/","title":"minitrade.broker","text":""},{"location":"api_broker/#minitrade.broker.base","title":"minitrade.broker.base","text":""},{"location":"api_broker/#minitrade.broker.base.Broker","title":"Broker","text":"<pre><code>Broker(account: BrokerAccount)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Broker is a base class that manages the connection to a broker system. Extend this class  to add a concrete implementation to talk to a particular broker.</p> <p>Parameters:</p> Name Type Description Default <code>account</code> <code>BrokerAccount</code> <p>a <code>BrokerAccount</code> instance</p> required"},{"location":"api_broker/#minitrade.broker.base.Broker.AVAILABLE_BROKERS","title":"AVAILABLE_BROKERS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AVAILABLE_BROKERS = {'IB': 'Interactive Brokers', 'Manual': 'Manual Trader'}\n</code></pre> <p>A dict mapping from broker alias to broker user-friendly name for supported brokers.</p>"},{"location":"api_broker/#minitrade.broker.base.Broker.cancel_order","title":"cancel_order  <code>abstractmethod</code>","text":"<pre><code>cancel_order(plan: TradePlan, order: RawOrder = None) -&gt; bool\n</code></pre> <p>Cancel a specific order or all pending orders of a trade plan if <code>order</code> is None.</p> <p>Parameters:</p> Name Type Description Default <code>plan</code> <code>TradePlan</code> <p>A trade plan</p> required <code>order</code> <code>RawOrder</code> <p>A <code>RawOrder</code> to be cancelled</p> <code>None</code>"},{"location":"api_broker/#minitrade.broker.base.Broker.connect","title":"connect  <code>abstractmethod</code>","text":"<pre><code>connect()\n</code></pre> <p>Set up a working connection to the broker.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If a working connection can't be established.</p>"},{"location":"api_broker/#minitrade.broker.base.Broker.disconnect","title":"disconnect  <code>abstractmethod</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from broker and release any resources.</p>"},{"location":"api_broker/#minitrade.broker.base.Broker.download_orders","title":"download_orders  <code>abstractmethod</code>","text":"<pre><code>download_orders() -&gt; DataFrame | None\n</code></pre> <p>Get recent orders at broker. RawOrder submitted creates a correspoing order on the broker side, which can have different status such as open, cancelled, error, etc.</p> <p>This function is called immediately before and after order submission to get the most  recent order information on the broker side. The orders returned should be persisted to database and can be used for display, order validation, statistics, and record keeping. Since order status can change over time, new status should overwrite past one.</p> <p>The number of orders returned depends on the data availability of each broker.</p> <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>A dataframe that contains recent order information</p>"},{"location":"api_broker/#minitrade.broker.base.Broker.download_trades","title":"download_trades  <code>abstractmethod</code>","text":"<pre><code>download_trades() -&gt; DataFrame | None\n</code></pre> <p>Get recent trades at broker. Trades are completed orders.</p> <p>This function is called immediately before and after order submission to get the most  recent trade information on the broker side. The trades returned should be persisted to database and can be used for display, order validation, statistics, and record keeping. Trade info is usually final.</p> <p>The number of trades returned depends on the data availability of particular broker.</p> <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>A dataframe that contains recently finished trades</p>"},{"location":"api_broker/#minitrade.broker.base.Broker.find_order","title":"find_order  <code>abstractmethod</code>","text":"<pre><code>find_order(order: RawOrder) -&gt; dict\n</code></pre> <p>Get last known order status, not necessarily latest.</p> <p>A subclass implementing this function only needs to look up orders from the database, instead of querying the broker directly, which can be slow. In scenarios where stale information can't be tolerated, <code>download_orders()</code> is always called before this  function is invoked.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>RawOrder</code> <p>A <code>RawOrder</code></p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dict that contains broker specific order infomation associated with the order, </p> <code>dict</code> <p>or None if no broker order is found.</p>"},{"location":"api_broker/#minitrade.broker.base.Broker.find_trades","title":"find_trades  <code>abstractmethod</code>","text":"<pre><code>find_trades(order: RawOrder) -&gt; dict\n</code></pre> <p>Get trade information associated with the raw <code>order</code>.</p> <p>A 'RawOrder' can be filled in multiple trades at different time and prices, therefore a list of trades may be returned.</p> <p>A subclass implementing this function only needs to look up trades from the database, instead of querying the broker directly, which can be slow. In scenarios where stale information can't be tolerated, <code>download_trades()</code> is always called before this  function is invoked.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>RawOrder</code> <p>A <code>RawOrder</code></p> required <p>Returns:</p> Type Description <code>dict</code> <p>A list of dict that contains broker specific trade infomation associated with the order, </p> <code>dict</code> <p>or None if no broker trade is found.</p>"},{"location":"api_broker/#minitrade.broker.base.Broker.format_trades","title":"format_trades  <code>abstractmethod</code>","text":"<pre><code>format_trades(orders: list[RawOrder]) -&gt; list[dict]\n</code></pre> <p>Get broker specific trade status corresponding to the list of orders and format     in dict like:     {         'ticker': ...,         'entry_time': ...,         'size': ...,         'entry_price': ...,         'commission': ...     }</p> <p>Parameters:</p> Name Type Description Default <code>orders</code> <code>list[RawOrder]</code> <p>A list of <code>RawOrder</code></p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>A list of completed trades with relevant information</p>"},{"location":"api_broker/#minitrade.broker.base.Broker.get_account_info","title":"get_account_info  <code>abstractmethod</code>","text":"<pre><code>get_account_info() -&gt; dict\n</code></pre> <p>Get broker account meta info</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dict that contains broker specific account information</p>"},{"location":"api_broker/#minitrade.broker.base.Broker.get_broker","title":"get_broker  <code>staticmethod</code>","text":"<pre><code>get_broker(account: BrokerAccount) -&gt; Broker\n</code></pre> <p>Create a broker connector for a <code>account</code> that specifies the type of broker and the login credentials.</p> <p>Parameters:</p> Name Type Description Default <code>account</code> <code>BrokerAccount</code> <p>A <code>BrokerAccount</code> instance</p> required <p>Returns:</p> Type Description <code>Broker</code> <p>A <code>Broker</code> instance</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the type of broker is not supported</p>"},{"location":"api_broker/#minitrade.broker.base.Broker.get_portfolio","title":"get_portfolio  <code>abstractmethod</code>","text":"<pre><code>get_portfolio() -&gt; DataFrame | None\n</code></pre> <p>Get account portfolio</p> <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>A dataframe that contains broker specific portfolio infomation</p>"},{"location":"api_broker/#minitrade.broker.base.Broker.is_ready","title":"is_ready  <code>abstractmethod</code>","text":"<pre><code>is_ready() -&gt; bool\n</code></pre> <p>Check if the broker connector has a working connection with the broker.</p> <p>All calls interacting with the broker system should only be sent after <code>is_ready</code> return True. </p> <p>Returns:</p> Type Description <code>bool</code> <p>True if a connection to broker is ready, otherwise False</p>"},{"location":"api_broker/#minitrade.broker.base.Broker.resolve_tickers","title":"resolve_tickers  <code>abstractmethod</code>","text":"<pre><code>resolve_tickers(ticker_css: str) -&gt; dict[str, list]\n</code></pre> <p>Resolve generic tickers to broker specific ticker IDs.</p> <p>Parameters:</p> Name Type Description Default <code>ticker_css</code> <code>str</code> <p>A list of tickers formatted as a comma separated string</p> required <p>Returns:</p> Type Description <code>dict[str, list]</code> <p>A dict mapping each generic ticker name to a list of broker ticker options. The format is like  {     TK1: [         {'id': id1, 'label': label1},          {'id': id2, 'label': label2}     ],      TK2: [         {'id': id1, 'label': label1}     ],     TK3: [] } where id is the broker specific ticker ID, label is a human readable string to help disambiguate the options.</p>"},{"location":"api_broker/#minitrade.broker.base.Broker.submit_order","title":"submit_order  <code>abstractmethod</code>","text":"<pre><code>submit_order(plan: TradePlan, order: RawOrder) -&gt; str\n</code></pre> <p>Submit an order to the broker.</p> <p>Parameters:</p> Name Type Description Default <code>plan</code> <code>TradePlan</code> <p>A trade plan</p> required <code>order</code> <code>RawOrder</code> <p>A <code>RawOrder</code> to be submitted</p> required <p>Returns:</p> Type Description <code>str</code> <p>Broker assigned order ID if order is submitted successfully, otherwise None</p>"},{"location":"api_broker/#minitrade.broker.base.BrokerAccount","title":"BrokerAccount  <code>dataclass</code>","text":"<pre><code>BrokerAccount(*, alias: str, broker: str, mode: str, username: str, password: str)\n</code></pre> <p>BrokerAccount describes a broker account, such as name, type, and login credentials.</p>"},{"location":"api_broker/#minitrade.broker.base.BrokerAccount.alias","title":"alias  <code>instance-attribute</code>","text":"<pre><code>alias: str\n</code></pre> <p>Account alias</p>"},{"location":"api_broker/#minitrade.broker.base.BrokerAccount.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker: str\n</code></pre> <p>Broker alias as in <code>Broker.AVAILABLE_BROKERS</code></p>"},{"location":"api_broker/#minitrade.broker.base.BrokerAccount.mode","title":"mode  <code>instance-attribute</code>","text":"<pre><code>mode: str\n</code></pre> <p>\"Live\" or \"Paper\". Note this is only a hint to help remember. Whether an account is live or paper depends on the account itself rather than this field.</p>"},{"location":"api_broker/#minitrade.broker.base.BrokerAccount.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password: str\n</code></pre> <p>Account password</p>"},{"location":"api_broker/#minitrade.broker.base.BrokerAccount.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username: str\n</code></pre> <p>Account username</p>"},{"location":"api_broker/#minitrade.broker.base.BrokerAccount.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete broker account from database.</p>"},{"location":"api_broker/#minitrade.broker.base.BrokerAccount.get_account","title":"get_account  <code>staticmethod</code>","text":"<pre><code>get_account(plan_or_alias: TradePlan | str) -&gt; BrokerAccount\n</code></pre> <p>Look up a broker account from a broker account <code>alias</code> or the alias  as specified in a <code>TradePlan</code>.</p> <p>Parameters:</p> Name Type Description Default <code>plan_or_alias</code> <code>TradePlan | str</code> <p>A trade plan or a broker account alias</p> required <p>Returns:</p> Type Description <code>BrokerAccount</code> <p>A broker account, or None if the alias is invalid</p>"},{"location":"api_broker/#minitrade.broker.base.BrokerAccount.list","title":"list  <code>staticmethod</code>","text":"<pre><code>list() -&gt; list[BrokerAccount]\n</code></pre> <p>Return the list of available broker accounts.</p> <p>Returns:</p> Type Description <code>list[BrokerAccount]</code> <p>A list of zero or more broker accounts</p>"},{"location":"api_broker/#minitrade.broker.base.BrokerAccount.save","title":"save","text":"<pre><code>save() -&gt; None\n</code></pre> <p>Save a broker account to database.</p>"},{"location":"api_broker/#minitrade.broker.base.OrderValidator","title":"OrderValidator","text":"<pre><code>OrderValidator(plan: TradePlan)\n</code></pre> <p>OrderValidator is responsible for integrity checks on a raw order before it's submitted to broker.</p>"},{"location":"api_broker/#minitrade.broker.base.OrderValidator.validate","title":"validate","text":"<pre><code>validate(order: RawOrder)\n</code></pre> <p>Run a bunch of checks to ensure the raw order is valid.</p> <p>For example, a valid order should:</p> <ul> <li>have valid values for all its attributes</li> <li>not be a duplicate of what has been submitted before</li> <li>be timely</li> </ul>"},{"location":"api_broker/#minitrade.broker.base.OrderValidatorLog","title":"OrderValidatorLog  <code>dataclass</code>","text":"<pre><code>OrderValidatorLog(*, id: str, order_id: str, order: str, result: str, exception: str | None = None, log_time: datetime)\n</code></pre> <p>OrderValidatorLog logs the results of order validation.</p>"},{"location":"api_broker/#minitrade.broker.base.OrderValidatorLog.exception","title":"exception  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exception: str | None = None\n</code></pre> <p>Exception that occurs during validation</p>"},{"location":"api_broker/#minitrade.broker.base.OrderValidatorLog.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Validator run ID</p>"},{"location":"api_broker/#minitrade.broker.base.OrderValidatorLog.log_time","title":"log_time  <code>instance-attribute</code>","text":"<pre><code>log_time: datetime\n</code></pre> <p>Log time</p>"},{"location":"api_broker/#minitrade.broker.base.OrderValidatorLog.order","title":"order  <code>instance-attribute</code>","text":"<pre><code>order: str\n</code></pre> <p>Raw order in Json format</p>"},{"location":"api_broker/#minitrade.broker.base.OrderValidatorLog.order_id","title":"order_id  <code>instance-attribute</code>","text":"<pre><code>order_id: str\n</code></pre> <p>Raw order ID</p>"},{"location":"api_broker/#minitrade.broker.base.OrderValidatorLog.result","title":"result  <code>instance-attribute</code>","text":"<pre><code>result: str\n</code></pre> <p>Validation output</p>"},{"location":"api_datasource/","title":"minitrade.datasource","text":""},{"location":"api_datasource/#minitrade.datasource.base","title":"minitrade.datasource.base","text":""},{"location":"api_datasource/#minitrade.datasource.base.QuoteSource","title":"QuoteSource","text":"<p>               Bases: <code>ABC</code></p> <p>QuoteSource is a base class that returns quote data for instruments. Extend this class to add a concrete implementation to get data from particular data source.</p> <p>At a minimum, the following methods should be implemented: <pre><code>class MyQuoteSource(QuoteSource):\n    def _ticker_timezone(self, ticker: str) -&gt; str:\n        pass\n\n    def _ticker_calendar(self, ticker: str) -&gt; str:\n        pass\n\n    def _daily_bar(self, ticker: str, start: str, end: str) -&gt; pd.DataFrame:\n        pass\n</code></pre></p>"},{"location":"api_datasource/#minitrade.datasource.base.QuoteSource.SYSTEM_SOURCES","title":"SYSTEM_SOURCES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SYSTEM_SOURCES = sorted(['Yahoo', 'EODHistoricalData', 'TwelveData', 'Alpaca', 'EastMoney', 'Tiingo', 'InteractiveBrokers', 'CboeIndex', 'CboeFutures'])\n</code></pre> <p>A list of names for supported quote sources as input to <code>QuoteSource.get_source()</code>.</p>"},{"location":"api_datasource/#minitrade.datasource.base.QuoteSource._daily_bar","title":"_daily_bar  <code>abstractmethod</code>","text":"<pre><code>_daily_bar(ticker: str, start: str, end: str) -&gt; DataFrame\n</code></pre> <p>Same as <code>daily_bar()</code> for only one ticker.</p> <p>This should be overridden in subclass to provide an implemention.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe with columns 'Open', 'High', 'Low', 'Close', 'Volume' indexed by datetime</p>"},{"location":"api_datasource/#minitrade.datasource.base.QuoteSource._minute_bar","title":"_minute_bar  <code>abstractmethod</code>","text":"<pre><code>_minute_bar(ticker: str, start: str, end: str, interval: int) -&gt; DataFrame\n</code></pre> <p>Same as <code>minute_bar()</code> for only one ticker.</p> <p>This should be overridden in subclass to provide an implemention.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe with columns 'Open', 'High', 'Low', 'Close', 'Volume' indexed by datetime</p>"},{"location":"api_datasource/#minitrade.datasource.base.QuoteSource._spot","title":"_spot  <code>abstractmethod</code>","text":"<pre><code>_spot(tickers: list[str]) -&gt; Series\n</code></pre> <p>Return spot prices for a list of tickers.</p>"},{"location":"api_datasource/#minitrade.datasource.base.QuoteSource._ticker_calendar","title":"_ticker_calendar  <code>abstractmethod</code>","text":"<pre><code>_ticker_calendar(ticker: str) -&gt; str\n</code></pre> <p>Get the calendar name of a ticker as recognized by <code>pandas_market_calendars</code>.</p>"},{"location":"api_datasource/#minitrade.datasource.base.QuoteSource._ticker_timezone","title":"_ticker_timezone  <code>abstractmethod</code>","text":"<pre><code>_ticker_timezone(ticker: str) -&gt; str\n</code></pre> <p>Get the timezone of a ticker.</p>"},{"location":"api_datasource/#minitrade.datasource.base.QuoteSource.daily_bar","title":"daily_bar","text":"<pre><code>daily_bar(tickers: list[str] | str, start: str = '2000-01-01', end: str = None, align: bool = True, normalize: bool = False, num_workers: int = 1) -&gt; DataFrame\n</code></pre> <p>Read end-of-day OHLCV data for a list of <code>tickers</code> starting from <code>start</code> date and ending on <code>end</code> date (both inclusive).</p> <p>Parameters:</p> Name Type Description Default <code>tickers</code> <code>list[str] | str</code> <p>Tickers as a list of string or a comma separated string without space</p> required <code>start</code> <code>str</code> <p>Start date in string format 'YYYY-MM-DD'</p> <code>'2000-01-01'</code> <code>end</code> <code>str</code> <p>End date in string format 'YYYY-MM-DD'</p> <code>None</code> <code>align</code> <code>bool</code> <p>True to align data to start on the same date, i.e. drop leading days when not all tickers have data available.</p> <code>True</code> <code>normalize</code> <code>bool</code> <p>True to normalize the close price on the start date to 1 for all tickers and scale all price data accordingly.</p> <code>False</code> <code>num_workers</code> <code>int</code> <p>Number of parallel workers to use for fetching data.</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe with 2-level columns, first level being the tickers, and the second level being columns 'Open', 'High', 'Low', 'Close', 'Volume'. The dataframe is indexed by datetime.</p>"},{"location":"api_datasource/#minitrade.datasource.base.QuoteSource.get_source","title":"get_source  <code>staticmethod</code>","text":"<pre><code>get_source(name: str, **kwargs: dict[str, Any]) -&gt; QuoteSource\n</code></pre> <p>Get quote source by name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Quote source name</p> required <code>kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments to be passed to the quote source constructor</p> <code>{}</code> <p>Returns:</p> Type Description <code>QuoteSource</code> <p>A QuoteSource instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the asked data source is not supported</p>"},{"location":"api_datasource/#minitrade.datasource.base.QuoteSource.is_trading_now","title":"is_trading_now","text":"<pre><code>is_trading_now(ticker: str) -&gt; bool\n</code></pre> <p>Check if a ticker is trading now.</p>"},{"location":"api_datasource/#minitrade.datasource.base.QuoteSource.list","title":"list  <code>staticmethod</code>","text":"<pre><code>list() -&gt; list[str]\n</code></pre> <p>List all available quote sources.</p>"},{"location":"api_datasource/#minitrade.datasource.base.QuoteSource.minute_bar","title":"minute_bar","text":"<pre><code>minute_bar(tickers: list[str] | str, start: str = None, end: str = None, interval: int = 1, num_workers: int = 1) -&gt; DataFrame\n</code></pre> <p>Read minute OHLCV data for a <code>ticker</code> starting from <code>start</code> date and ending on <code>end</code> date (both inclusive).</p> <p>Parameters:</p> Name Type Description Default <code>tickers</code> <code>list[str] | str</code> <p>Tickers as a list or comma-separated string</p> required <code>start</code> <code>str</code> <p>Start date in string format 'YYYY-MM-DD'</p> <code>None</code> <code>end</code> <code>str</code> <p>End date in string format 'YYYY-MM-DD'</p> <code>None</code> <code>interval</code> <code>int</code> <p>Interval in minutes</p> <code>1</code> <code>num_workers</code> <code>int</code> <p>Number of parallel workers to use for fetching data.</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe with columns 'Open', 'High', 'Low', 'Close', 'Volume' indexed by datetime</p>"},{"location":"api_datasource/#minitrade.datasource.base.QuoteSource.monthly_bar","title":"monthly_bar","text":"<pre><code>monthly_bar(tickers: list[str] | str, start: str = '2020-01-01', end: str = None, align: bool = True, normalize: bool = False, num_workers: int = 1) -&gt; DataFrame\n</code></pre> <p>Read monthly OHLCV data for a list of <code>tickers</code> starting from <code>start</code> date and ending on <code>end</code> date (both inclusive).</p> <p>Parameters:</p> Name Type Description Default <code>tickers</code> <code>list[str] | str</code> <p>Tickers as a list of string or a comma separated string without space</p> required <code>start</code> <code>str</code> <p>Start date in string format 'YYYY-MM'</p> <code>'2020-01-01'</code> <code>end</code> <code>str</code> <p>End date in string format 'YYYY-MM'</p> <code>None</code> <code>align</code> <code>bool</code> <p>True to align data to start on the same date, i.e. drop leading days when not all tickers have data available.</p> <code>True</code> <code>normalize</code> <code>bool</code> <p>True to normalize the close price on the start date to 1 for all tickers and scale all price data accordingly.</p> <code>False</code> <code>num_workers</code> <code>int</code> <p>Number of parallel workers to use for fetching data.</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe with 2-level columns, first level being the tickers, and the second level being columns 'Open', 'High', 'Low', 'Close', 'Volume'. The dataframe is indexed by last day of month.</p>"},{"location":"api_datasource/#minitrade.datasource.base.QuoteSource.spot","title":"spot","text":"<pre><code>spot(tickers: list[str] | str) -&gt; Series\n</code></pre> <p>Read current quote for a list of <code>tickers</code>.</p> <p>Parameters:</p> Name Type Description Default <code>tickers</code> <code>list[str] | str</code> <p>Tickers as a list of string or a comma separated string without space</p> required <p>Returns:</p> Type Description <code>Series</code> <p>Current quotes indexed by ticker as a pandas Series</p>"},{"location":"api_datasource/#minitrade.datasource.base.QuoteSource.ticker_calendar","title":"ticker_calendar","text":"<pre><code>ticker_calendar(ticker: str) -&gt; str\n</code></pre> <p>Get the calendar name of a ticker.</p>"},{"location":"api_datasource/#minitrade.datasource.base.QuoteSource.ticker_timezone","title":"ticker_timezone","text":"<pre><code>ticker_timezone(ticker: str) -&gt; str\n</code></pre> <p>Get the timezone of a ticker.</p>"},{"location":"api_datasource/#minitrade.datasource.base.QuoteSource.today","title":"today","text":"<pre><code>today(ticker: str) -&gt; datetime\n</code></pre> <p>Get today's date in a ticker's local timezone.</p>"},{"location":"backtesting/","title":"Backtesting","text":"<p><code>Minitrade</code> uses Backtesting.py as the core library for backtesting and adds the capability to implement multi-asset strategies. </p>"},{"location":"backtesting/#strategy-basics","title":"Strategy Basics","text":"<p>A strategy is defined by subclassing <code>Strategy</code> and implementing the <code>init()</code> and <code>next()</code> methods. </p> <pre><code>from minitrade.backtest import Strategy\n\nclass MyStrategy(Strategy):\n\n    def init(self):\n        pass\n\n    def next(self):\n        pass\n</code></pre> <p>The <code>init()</code> method is called once at the beginning of the backtest to initialize the strategy. The <code>next()</code> method is called for each bar in the data to generate trading signals.</p>"},{"location":"backtesting/#historical-data","title":"Historical Data","text":"<p>The historical data is accessed through the <code>self.data</code> object. It's an instance of <code>_Data</code>, which is a wrapper around a DataFrame with a 2-level column index, where the first level is the ticker and the second level is the OHLCV data. The raw DataFrame can be accessed with the <code>.df</code> accessor.</p> <p>For instance,</p> <pre><code># self.data\n&lt;Data i=4 (2018-01-08) \n    ('AAPL', 'Open')=41.38, \n    ('AAPL', 'High')=41.68, \n    ('AAPL', 'Low')=41.28, \n    ('AAPL', 'Close')=41.38, \n    ('AAPL', 'Volume')=82271200.0&gt;\n\n# self.data.df\n            AAPL                                \n            Open   High    Low  Close     Volume\nDate\n2018-01-02  40.39  40.90  40.18  40.89  102223600\n2018-01-03  40.95  41.43  40.82  40.88  118071600\n2018-01-04  40.95  41.18  40.85  41.07   89738400\n2018-01-05  41.17  41.63  41.08  41.54   94640000\n2018-01-08  41.38  41.68  41.28  41.38   82271200\n</code></pre>"},{"location":"backtesting/#indicators","title":"Indicators","text":"<p>Indicators can be created using the <code>I()</code> method. The method takes a DataFrame or Series and an optional name argument. The indicator is calculated once in the <code>init()</code> method and can be accessed in the <code>next()</code> method.</p> <pre><code>class MyStrategy(Strategy):\n\n    def init(self):\n        self.sma = self.I(self.data.Close.df.rolling(10).mean(), name='SMA')\n\n    def next(self):\n        if self.data.Close[-1] &gt; self.sma[-1]:\n            print('Buy signal')\n        else:\n            print('Sell signal')\n</code></pre>"},{"location":"backtesting/#orders","title":"Orders","text":"<p>The <code>buy()</code> and <code>sell()</code> methods are used to place orders. The <code>position()</code> method returns the current position, which can be used to close the position using the <code>close()</code> method.</p> <pre><code>class MyStrategy(Strategy):\n\n    def init(self):\n        self.sma = self.I(self.data.Close.df.rolling(10).mean(), name='SMA')\n\n    def next(self):\n        if self.data.Close[-1] &gt; self.sma[-1]:\n            if self.position().size == 0:\n                self.buy()\n        else:\n            if self.position().size &gt; 0:\n                self.position().close()\n</code></pre>"},{"location":"backtesting/#single-asset-strategy","title":"Single Asset Strategy","text":"<p>For single asset strategies, those written for <code>Backtesting.py</code> can be easily adapted to work with Minitrade. The following example from <code>Backtesting.py</code> illustrates what changes are necessary:</p> <pre><code>from minitrade.backtest import Strategy                                 #1\nfrom minitrade.backtest.core.lib import crossover                       #1\nfrom minitrade.backtest.core.test import SMA                            #1\n\nclass SmaCross(Strategy):\n    fast = 10\n    slow = 20\n\n    def init(self):\n        price = self.data.Close.df                                      #2\n        self.ma1 = self.I(SMA, price, self.fast, overlay=True)          #3\n        self.ma2 = self.I(SMA, price, self.slow, overlay=True)          #3\n\n    def next(self):\n        if crossover(self.ma1, self.ma2):\n            self.position().close()                                     #4\n            self.buy()\n        elif crossover(self.ma2, self.ma1):\n            self.position().close()                                     #4\n            self.sell()\n\n\nbt = Backtest(GOOG, SmaCross, commission=.001)\nstats = bt.run()\nbt.plot()\n</code></pre> <ol> <li>Change to import from minitrade modules. Generally <code>backtesting</code> becomes <code>minitrade.backtest.core</code>. Note that importing from <code>minitrade.backtest.core.test</code> is discouraged. <code>SMA</code> can be easily achieved using <code>self.data.Close.df.rolling(n).mean()</code> as shown in earlier example.</li> <li>To access the historical data as a Pandas Series or DataFrame, use <code>self.data.Close.df</code> instead of <code>self.data.Close</code>.</li> <li>Minitrade doesn't try to guess where to plot the indicators. So if you want to overlay the indicators on the main chart, set <code>overlay=True</code> explicitly.</li> <li><code>Strategy.position</code> is no longer a property but a function. Any occurrence of <code>self.position</code> should be changed to <code>self.position()</code>. </li> </ol> <p>The plot generated by the above code will look like this:</p> <p></p> <p>Beyond this simple example, there are other caveats you should be aware of. Check out compatibility for more details. Also some original utility functions and strategy classes only make sense for single asset strategy. Don't use those in multi-asset strategies.</p>"},{"location":"backtesting/#multi-asset-strategy","title":"Multi-Asset Strategy","text":"<p><code>Minitrade</code> extends <code>Backtesting.py</code> to support backtesting of multi-asset strategies. </p>"},{"location":"backtesting/#data-input","title":"Data Input","text":"<p>A multi-asset strategy requires a DataFrame with a 2-level column index as its data input. For instance, suppose you have a strategy aiming to invest in AAPL and GOOG as a portfolio. In this case, the <code>data</code> input to <code>Backtest()</code> should follow this format:</p> <pre><code># bt = Backtest(data, AaplGoogStrategy)\n# print(data)\n\n          AAPL                              GOOG \n          Open  High  Low   Close Volume    Open  High  Low   Close Volume\nDate          \n2018-01-02 40.39 40.90 40.18 40.89 102223600 52.42 53.35 52.26 53.25 24752000\n2018-01-03 40.95 41.43 40.82 40.88 118071600 53.22 54.31 53.16 54.12 28604000\n2018-01-04 40.95 41.18 40.85 41.07 89738400 54.40 54.68 54.20 54.32 20092000\n2018-01-05 41.17 41.63 41.08 41.54 94640000 54.70 55.21 54.60 55.11 25582000\n2018-01-08 41.38 41.68 41.28 41.38 82271200 55.11 55.56 55.08 55.35 20952000\n</code></pre> <p>As mentioned earlier, the historical data is accessed through the <code>self.data</code> object.</p> <pre><code># When called from within Strategy.init()\n\n# self.data\n&lt;Data i=4 (2018-01-08) ('AAPL', 'Open')=41.38, ('AAPL', 'High')=41.68, ('AAPL', 'Low')=41.28, ('AAPL', 'Close')=41.38, ('AAPL', 'Volume')=82271200.0, ('GOOG', 'Open')=55.11, ('GOOG', 'High')=55.56, ('GOOG', 'Low')=55.08, ('GOOG', 'Close')=55.35, ('GOOG', 'Volume')=20952000.0&gt;\n\n# self.data.df\n          AAPL                              GOOG \n          Open  High  Low   Close Volume    Open  High  Low   Close Volume\nDate          \n2018-01-02 40.39 40.90 40.18 40.89 102223600 52.42 53.35 52.26 53.25 24752000\n2018-01-03 40.95 41.43 40.82 40.88 118071600 53.22 54.31 53.16 54.12 28604000\n2018-01-04 40.95 41.18 40.85 41.07 89738400 54.40 54.68 54.20 54.32 20092000\n2018-01-05 41.17 41.63 41.08 41.54 94640000 54.70 55.21 54.60 55.11 25582000\n2018-01-08 41.38 41.68 41.28 41.38 82271200 55.11 55.56 55.08 55.35 20952000\n</code></pre>"},{"location":"backtesting/#pandas-ta-integration","title":"<code>Pandas TA</code> Integration","text":"<p>For streamlined indicator calculation, Minitrade has built-in integration with pandas_ta. Accessing <code>pandas_ta</code> is made easy through the <code>.ta</code> property of any DataFrame. Refer to the documentation for usage instructions. Moreover, <code>.ta</code> has been augmented to fully support 2-level DataFrames.</p> <p>For example,</p> <pre><code># print(self.data.df.ta.sma(3))\n\n                 AAPL       GOOG\nDate                                            \n2018-01-02         NaN        NaN\n2018-01-03         NaN        NaN\n2018-01-04   40.946616  53.898000\n2018-01-05   41.163408  54.518500\n2018-01-08   41.331144  54.926167\n</code></pre> <p>As a shortcut, <code>self.data.ta.sma(3)</code> works the same on <code>self.data</code>.</p>"},{"location":"backtesting/#indicators_1","title":"Indicators","text":"<p><code>self.I()</code> accepts both DataFrame/Series and functions as arguments to define an indicator. When a DataFrame/Series is provided, it's assumed to have the same index as <code>self.data</code>. For instance,</p> <pre><code>self.sma = self.I(self.data.df.ta.sma(3), name='SMA_3')\n</code></pre> <p>Within <code>Strategy.next()</code>, indicators are returned as type <code>_Array</code>, essentially <code>numpy.ndarray</code>, similar to <code>Backtesting.py</code>. The <code>.df</code> accessor returns either a <code>DataFrame</code> or <code>Series</code> of the corresponding value. It's the caller's responsibility to know which exact type should be returned. The <code>.s</code> accessor is also available but serves only as syntactic sugar to return a <code>Series</code>. If the actual data is a DataFrame, <code>.s</code> throws a <code>ValueError</code>.</p>"},{"location":"backtesting/#weight-allocation","title":"Weight Allocation","text":"<p>A key addition to support multi-asset strategy is a <code>Strategy.alloc</code> attribute, which, combined with <code>Strategy.rebalance()</code>, allows specifying how portfolio value should be allocated among the different assets.</p> <p><code>Strategy.alloc</code> is an instance of <code>Allocation</code>. The Allocation class manages the allocation of values among different assets in a portfolio. It provides methods for creating and managing asset buckets, assigning weights to assets, and merging the weights into the parent allocation object, which is then used to rebalance the portfolio. </p>"},{"location":"backtesting/#example","title":"Example","text":"<pre><code>from minitrade.backtest import Strategy\n\nclass MyStrategy(Strategy):\n\n    lookback = 10\n\n    def init(self):\n        self.roc = self.I(self.data.ta.roc(self.lookback), name='ROC')     #1\n\n    def next(self):\n        self.alloc.assume_zero()                                #2\n        roc = self.roc.df.iloc[-1]                              #3\n        (self.alloc.bucket['equity']                            #4\n            .append(roc.sort_values(ascending=False), roc &gt; 0)  #5\n            .trim(3)                                            #6\n            .weight_explicitly(1/3)                             #7\n            .apply())                                           #8\n        self.rebalance(cash_reserve=0.01)                       #9\n</code></pre> <p>The above illustrates the general workflow of defining a multi-asset strategy:</p> <ol> <li>Calculate the indicator. It uses <code>.ta</code> accessor to calculate the rate of change of the close prices over a 10-day period, wraps the result in <code>I()</code> to create an indicator named <code>ROC</code>, and assigns it to <code>self.roc</code>.</li> <li><code>self.alloc.assume_zero()</code> resets the weight allocation to zero at the beginning of each <code>next()</code> call.</li> <li>Get the latest ROC value from the <code>self.roc</code> indicator and assign it to <code>roc</code>.</li> <li>Create a new bucket named <code>equity</code> in the allocation object.</li> <li>Add stocks with positive ROC, ranking in descending order, to the <code>equity</code> bucket.</li> <li>Trim the <code>equity</code> bucket to contain a maximum of top 3 stocks.</li> <li>Allocate 1/3 of the portfolio value to each stock in the <code>equity</code> bucket.</li> <li>Apply the weight allocation to the portfolio.</li> <li>Rebalance the portfolio based on the current allocation.</li> </ol>"},{"location":"backtesting/#data-source","title":"Data Source","text":"<p><code>Minitrade</code> provides built-in data sources to fetch historical quotes from Yahoo Finance and others. The data source can be instantiated by name:</p> <pre><code>from minitrade.datasource import QuoteSource\n\nyahoo = QuoteSource.get_source('Yahoo')\ndata = yahoo.daily_bar('AAPL', start='2018-01-01', end='2019-01-01')\n</code></pre> <p>The <code>daily_bar()</code> method returns a DataFrame with the following format:</p> <pre><code>            AAPL                                \n            Open   High    Low  Close     Volume\nDate\n2018-01-02  40.28  40.79  40.07  40.78  102223600\n2018-01-03  40.84  41.32  40.71  40.77  118071600\n2018-01-04  40.84  41.06  40.73  40.96   89738400\n2018-01-05  41.06  41.51  40.96  41.43   94640000\n2018-01-08  41.27  41.57  41.17  41.27   82271200\n...                          ...    ...    ...    ...        ...\n</code></pre> <p>The data source can also fetch historical quotes for multiple stocks at once. </p> <pre><code>data = yahoo.daily_bar(['AAPL', 'GOOG'], start='2018-01-01', end='2019-01-01')\n</code></pre> <p>It returns a DataFrame with a 2-level column index as required for multi-asset strategies:</p> <pre><code>          AAPL                              GOOG \n          Open  High  Low   Close Volume    Open  High  Low   Close Volume\nDate\n2018-01-02 40.39 40.90 40.18 40.89 102223600 52.42 53.35 52.26 53.25 24752000\n2018-01-03 40.95 41.43 40.82 40.88 118071600 53.22 54.31 53.16 54.12 28604000\n2018-01-04 40.95 41.18 40.85 41.07 89738400 54.40 54.68 54.20 54.32 20092000\n2018-01-05 41.17 41.63 41.08 41.54 94640000 54.70 55.21 54.60 55.11 25582000\n2018-01-08 41.38 41.68 41.28 41.38 82271200 55.11 55.56 55.08 55.35 20952000\n...                          ...    ...    ...    ...        ...\n</code></pre>"},{"location":"backtesting/#revisit-selfdata","title":"Revisit <code>self.data</code>","text":"<p>Much of writing a strategy involves manipulating the historical data. <code>self.data</code> is a key object that provides access to the historical data. It's an instance of <code>_Data</code>, which is a wrapper around the DataFrame that supports revealing data progressively to prevent look-ahead bias.</p>"},{"location":"backtesting/#multiple-assets","title":"Multiple Assets","text":"<p>Suppose the following data is used to backtest a multi-asset strategy. </p> <pre><code>          AAPL                              GOOG \n          Open  High  Low   Close Volume    Open  High  Low   Close Volume\nDate\n2018-01-02 40.39 40.90 40.18 40.89 102223600 52.42 53.35 52.26 53.25 24752000\n2018-01-03 40.95 41.43 40.82 40.88 118071600 53.22 54.31 53.16 54.12 28604000\n2018-01-04 40.95 41.18 40.85 41.07 89738400 54.40 54.68 54.20 54.32 20092000\n2018-01-05 41.17 41.63 41.08 41.54 94640000 54.70 55.21 54.60 55.11 25582000\n2018-01-08 41.38 41.68 41.28 41.38 82271200 55.11 55.56 55.08 55.35 20952000\n</code></pre> <p>Let's see how <code>self.data</code> can be used within the strategy:</p>"},{"location":"backtesting/#strategyinit","title":"<code>Strategy.init()</code>","text":"<p>In the <code>init()</code> method, the full length of historical data is available. The following illustrates how to slice the data in different, sometimes equivalent, ways:</p> <pre><code># self.data\n&lt;Data i=4 (2018-01-08) ('AAPL', 'Open')=41.38, ('AAPL', 'High')=41.68, ('AAPL', 'Low')=41.28, ('AAPL', 'Close')=41.38, ('AAPL', 'Volume')=82271200.0, ('GOOG', 'Open')=55.11, ('GOOG', 'High')=55.56, ('GOOG', 'Low')=55.08, ('GOOG', 'Close')=55.35, ('GOOG', 'Volume')=20952000.0&gt;\n\n# self.data.df\n          AAPL                              GOOG \n          Open  High  Low   Close Volume    Open  High  Low   Close Volume\nDate          \n2018-01-02 40.39 40.90 40.18 40.89 102223600 52.42 53.35 52.26 53.25 24752000\n2018-01-03 40.95 41.43 40.82 40.88 118071600 53.22 54.31 53.16 54.12 28604000\n2018-01-04 40.95 41.18 40.85 41.07 89738400 54.40 54.68 54.20 54.32 20092000\n2018-01-05 41.17 41.63 41.08 41.54 94640000 54.70 55.21 54.60 55.11 25582000\n2018-01-08 41.38 41.68 41.28 41.38 82271200 55.11 55.56 55.08 55.35 20952000\n\n# self.data.Close\n[[40.89 53.25]\n [40.88 54.12]\n [41.07 54.32]\n [41.54 55.11]\n [41.38 55.35]]\n\n# self.data.Close.df\n            AAPL   GOOG\nDate                                     \n2018-01-02  40.89  53.25\n2018-01-03  40.88  54.12\n2018-01-04  41.07  54.32\n2018-01-05  41.54  55.11\n2018-01-08  41.38  55.35\n\n# self.data.df.xs(\"Close\", axis=1, level=1)\n            AAPL   GOOG\nDate                                     \n2018-01-02  40.89  53.25\n2018-01-03  40.88  54.12\n2018-01-04  41.07  54.32\n2018-01-05  41.54  55.11\n2018-01-08  41.38  55.35\n\n# self.data.Close[-1]\n[41.38 55.35]\n\n# self.data.Close.df.iloc[-1]\nAAPL    41.38\nGOOG    55.35\nName: 2018-01-08, dtype: float64\n\n# self.data[\"AAPL\"]\n[[4.039000e+01 4.090000e+01 4.018000e+01 4.089000e+01 1.022236e+08]\n [4.095000e+01 4.143000e+01 4.082000e+01 4.088000e+01 1.180716e+08]\n [4.095000e+01 4.118000e+01 4.085000e+01 4.107000e+01 8.973840e+07]\n [4.117000e+01 4.163000e+01 4.108000e+01 4.154000e+01 9.464000e+07]\n [4.138000e+01 4.168000e+01 4.128000e+01 4.138000e+01 8.227120e+07]]\n\n# self.data[\"AAPL\"].df\n            Open   High    Low  Close     Volume\nDate                                                              \n2018-01-02  40.39  40.90  40.18  40.89  102223600\n2018-01-03  40.95  41.43  40.82  40.88  118071600\n2018-01-04  40.95  41.18  40.85  41.07   89738400\n2018-01-05  41.17  41.63  41.08  41.54   94640000\n2018-01-08  41.38  41.68  41.28  41.38   82271200\n\n# self.data.df[\"AAPL\"]\n            Open   High    Low  Close     Volume\nDate                                                              \n2018-01-02  40.39  40.90  40.18  40.89  102223600\n2018-01-03  40.95  41.43  40.82  40.88  118071600\n2018-01-04  40.95  41.18  40.85  41.07   89738400\n2018-01-05  41.17  41.63  41.08  41.54   94640000\n2018-01-08  41.38  41.68  41.28  41.38   82271200\n\n# self.data[\"AAPL\", \"Close\"]\n[40.89 40.88 41.07 41.54 41.38]\n\n# self.data[\"AAPL\", \"Close\"].df\nDate\n2018-01-02    40.89\n2018-01-03    40.88\n2018-01-04    41.07\n2018-01-05    41.54\n2018-01-08    41.38\nName: (AAPL, Close), dtype: float64\n\n# self.data.df[(\"AAPL\",\"Close\")]\nDate\n2018-01-02    40.89\n2018-01-03    40.88\n2018-01-04    41.07\n2018-01-05    41.54\n2018-01-08    41.38\nName: (AAPL, Close), dtype: float64\n\n# self.data[\"AAPL\", \"Close\"][-1]\n41.38\n\n# self.data[\"AAPL\", \"Close\"].df[-1]\n41.38\n\n# self.data.df[(\"AAPL\",\"Close\")][-1]\n41.38\n</code></pre> <p>Since <code>Strategy.init()</code> is only called once, performance is generally not an issue. It's recommended to use <code>.df</code> property that return DataFrame to simplify further processing.</p> <p>Here are some other notable properties of <code>self.data</code>:</p> <pre><code># self.data.tickers\n['AAPL', 'GOOG']\n\n# self.data.index\nDatetimeIndex(['2018-01-02', '2018-01-03',\n               '2018-01-04', '2018-01-05',\n               '2018-01-08'],\n              dtype='datetime64[ns]', name='Date', freq=None)\n</code></pre>"},{"location":"backtesting/#strategynext","title":"Strategy.next()","text":"<p>In <code>Strategy.next()</code>, both <code>self.data</code> and registered indicators are revealed progressively to prevent look-ahead bias. </p> <p>Since <code>Strategy.next()</code> is called for every bar in a backtest and optimizing a strategy may take many backtest runs, data indexing performance can be a concern in <code>Strategy.next()</code>. Therefore, indicators are returned as Numpy array by default, for example:</p> <pre><code># self.sma at time step 4\n[[        nan         nan]\n [        nan         nan]\n [40.94666667 53.89666667]\n [41.16333333 54.51666667]]\n</code></pre> <p>To access the DataFrame version of indicators, use <code>.df</code> property:</p> <pre><code># self.sma.df at time step 4\n                                AAPL       GOOG\nDate                                             \n2018-01-02        NaN        NaN\n2018-01-03        NaN        NaN\n2018-01-04  40.946667  53.896667\n2018-01-05  41.163333  54.516667\n</code></pre> <p><code>len(self.data)</code> returns the current time step, and <code>self.data.now</code> returns the current simulation time. They can be used to take actions at fixed time interval or on specific days.</p> <pre><code># rebalance every 10 days\nif len(self.data) % 10 == 0:\n    self.rebalance()\n\n# rebalance every Friday\nif self.data.now.weekday() == 4:\n    self.rebalance()\n\n# rebalance on the first trading day of each month\nif self.data.index[-1].month != self.data.index[-2].month:\n    self.rebalance()\n</code></pre>"},{"location":"backtesting/#single-asset","title":"Single Asset","text":"<p>Suppose the following data is used to backtest a single asset strategy. </p> <pre><code>          AAPL                              \n          Open  High  Low   Close Volume\nDate\n2018-01-02 40.39 40.90 40.18 40.89 102223600\n2018-01-03 40.95 41.43 40.82 40.88 118071600\n2018-01-04 40.95 41.18 40.85 41.07 89738400\n2018-01-05 41.17 41.63 41.08 41.54 94640000\n2018-01-08 41.38 41.68 41.28 41.38 82271200\n</code></pre> <p>Since there is only one asset, specifying the asset name is not necessary. <code>self.data</code> can be accessed as follows:</p> <pre><code># self.data.the_ticker\nAAPL\n\n# self.data\n&lt;Data i=4 (2018-01-08) ('AAPL', 'Open')=41.38, ('AAPL', 'High')=41.68, ('AAPL', 'Low')=41.28, ('AAPL', 'Close')=41.38, ('AAPL', 'Volume')=82271200.0&gt;\n\n# self.data.df\n            Open   High    Low  Close     Volume\nDate                                                              \n2018-01-02  40.39  40.90  40.18  40.89  102223600\n2018-01-03  40.95  41.43  40.82  40.88  118071600\n2018-01-04  40.95  41.18  40.85  41.07   89738400\n2018-01-05  41.17  41.63  41.08  41.54   94640000\n2018-01-08  41.38  41.68  41.28  41.38   82271200\n\n# self.data.Close\n[40.89 40.88 41.07 41.54 41.38]\n\n# self.data[\"Close\"]\n[40.89 40.88 41.07 41.54 41.38]\n\n# self.data.Close.df\nDate\n2018-01-02    40.89\n2018-01-03    40.88\n2018-01-04    41.07\n2018-01-05    41.54\n2018-01-08    41.38\nName: AAPL, dtype: float64\n\n# self.data[\"Close\"].df\nDate\n2018-01-02    40.89\n2018-01-03    40.88\n2018-01-04    41.07\n2018-01-05    41.54\n2018-01-08    41.38\nName: AAPL, dtype: float64\n\n# self.data.df[\"Close\"]\nDate\n2018-01-02    40.89\n2018-01-03    40.88\n2018-01-04    41.07\n2018-01-05    41.54\n2018-01-08    41.38\nName: Close, dtype: float64\n\n# self.data.Close[-1]\n41.38\n\n# self.data.Close.df.iloc[-1]\n41.38\n\n# self.data[\"Close\"][-1]\n41.38\n\n# self.data[\"Close\"].df[-1]\n41.38\n\n# self.data.df[\"Close\"][-1]\n41.38\n</code></pre>"},{"location":"backtesting/#backtest","title":"Backtest","text":"<p>Once the data and strategy are defined, the backtest can be run as follows:</p> <pre><code>from minitrade.backtest import Backtest\n\nbt = Backtest(data, MyStrategy)\nresult = bt.run()\n</code></pre> <p>The date range for backtesting is inferred from the data. </p> <p>The <code>run()</code> method returns a <code>pandas.Series</code> with the backtest statistics:</p> <pre><code># print(result)\nStart                                                   2023-01-03 00:00:00\nEnd                                                     2024-03-28 00:00:00\nDuration                                                  450 days 00:00:00\nExposure Time [%]                                                 88.745981\nEquity Final [$]                                                 11860.6813\nEquity Peak [$]                                                11879.591159\nReturn [%]                                                        18.606813\nBuy &amp; Hold Return [%]                                             12.122283\nReturn (Ann.) [%]                                                 15.357352\nVolatility (Ann.) [%]                                             15.370613\nSharpe Ratio                                                       0.999137\nSortino Ratio                                                      1.717817\nCalmar Ratio                                                       0.945122\nMax. Drawdown [%]                                                -16.249076\nAvg. Drawdown [%]                                                 -3.229986\nMax. Drawdown Duration                                    181 days 00:00:00\nAvg. Drawdown Duration                                     35 days 00:00:00\n# Trades                                                                111\nWin Rate [%]                                                      64.864865\nBest Trade [%]                                                    28.119439\nWorst Trade [%]                                                   -6.810767\nAvg. Trade [%]                                                     2.376234\nMax. Trade Duration                                        66 days 00:00:00\nAvg. Trade Duration                                        16 days 00:00:00\nProfit Factor                                                       3.35965\nExpectancy [%]                                                     2.577326\nSQN                                                                1.246637\nKelly Criterion                                                    0.242071\n_strategy                                                        MyStrategy\n_equity_curve                               Equity          MMM         ...\n_trades                        EntryBar  ExitBar Ticker  Size  EntryPric...\n_orders                              Ticker  Side  Size\nSignalTime      ...\n_positions                {'MMM': 37, 'AXP': 17, 'AAPL': 0, 'BA': 0, 'CV...\n_trade_start_bar                                                         10\ndtype: object\n</code></pre> <p>The backtest result can be visually inspected using the <code>plot()</code> method:</p> <pre><code>bt.plot(plot_allocation=True)\n</code></pre> <p></p>"},{"location":"backtesting/#optimization","title":"Optimization","text":"<p><code>Minitrade</code> provides a simple interface to optimize strategy parameters. The <code>optimize()</code> method takes a list of parameters to optimize, a constraint function, and a metric to maximize.</p> <pre><code>stats, heatmap = bt.optimize(\n    lookback=range(10, 60, 10),\n    constraint=None,\n    maximize='Equity Final [$]',\n    random_state=0,\n    return_heatmap=True)\n</code></pre> <p>It returns the backtest statistics for the optimal parameter and the results for each parameter combination.</p> <pre><code># print(heatmap)\nlookback\n10          11839.802638\n20          10751.761075\n30          11462.385435\n40          10283.880003\n50          10458.447683\nName: Equity Final [$], dtype: float64\n</code></pre>"},{"location":"backtesting/#further-reading","title":"Further Reading","text":"<p>The API Reference provides detailed information on the classes and methods available in <code>Minitrade</code>.</p>"},{"location":"cli/","title":"Command Line","text":"<p>Minitrade provides a command line interface to manage the lifecycles of background services, include:</p> <ul> <li>Scheduler</li> <li>IB gateway</li> <li>Web UI</li> </ul>"},{"location":"cli/#minitrade","title":"minitrade","text":"<p>Usage:</p> <pre><code>minitrade [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#backtest","title":"backtest","text":"<p>Run backtest for particular plan</p> <p>Usage:</p> <pre><code>minitrade backtest [OPTIONS] PLAN_ID_OR_NAME\n</code></pre> <p>Options:</p> Name Type Description Default <code>--run_id</code> text Specify an unique run ID manually None <code>--dryrun</code> boolean Dry run only, don't place orders <code>False</code> <code>--pytest</code> boolean Run in test mode <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#ib","title":"ib","text":"<p>Manage the execution of IB gateway</p> <p>Usage:</p> <pre><code>minitrade ib [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#diagnose","title":"diagnose","text":"<p>Diagnose IB login issues</p> <p>Usage:</p> <pre><code>minitrade ib diagnose [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#login","title":"login","text":"<p>Login IB gateway to a particular account</p> <p>Usage:</p> <pre><code>minitrade ib login [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-a</code>, <code>--alias</code> text IB account alias None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#logout","title":"logout","text":"<p>Logout IB gateway from all accounts</p> <p>Usage:</p> <pre><code>minitrade ib logout [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#start","title":"start","text":"<p>Start IB gateway</p> <p>Usage:</p> <pre><code>minitrade ib start [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#status","title":"status","text":"<p>Check IB gateway status</p> <p>Usage:</p> <pre><code>minitrade ib status [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#stop","title":"stop","text":"<p>Stop IB gateway</p> <p>Usage:</p> <pre><code>minitrade ib stop [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#init","title":"init","text":"<p>Initialize Minitrade</p> <p>Usage:</p> <pre><code>minitrade init [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-y</code>, <code>--yes</code> boolean Don't ask for confirmation of inplace upgrade <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#scheduler","title":"scheduler","text":"<p>Manage scheduler and scheduled jobs</p> <p>Usage:</p> <pre><code>minitrade scheduler [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#schedule","title":"schedule","text":"<p>Schedule a trade plan</p> <p>Usage:</p> <pre><code>minitrade scheduler schedule [OPTIONS] PLAN_ID\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#start_1","title":"start","text":"<p>Start scheduler</p> <p>Usage:</p> <pre><code>minitrade scheduler start [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#status_1","title":"status","text":"<p>Check scheduler status</p> <p>Usage:</p> <pre><code>minitrade scheduler status [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#stop_1","title":"stop","text":"<p>Stop scheduler</p> <p>Usage:</p> <pre><code>minitrade scheduler stop [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#unschedule","title":"unschedule","text":"<p>Unschedule a trade plan</p> <p>Usage:</p> <pre><code>minitrade scheduler unschedule [OPTIONS] PLAN_ID\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#web","title":"web","text":"<p>Manage web UI</p> <p>Usage:</p> <pre><code>minitrade web [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#start_2","title":"start","text":"<p>Launch web UI</p> <p>Usage:</p> <pre><code>minitrade web start [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code> <pre><code>:list_subcommands\n</code></pre>"},{"location":"compatibility/","title":"Compatibility with Backtesting.py","text":"<p>While Minitrade is largely compatible with Backtesting.py for single asset strategy, some breaking changes still exist to support multi-asset strategies and to simplify usage.</p>"},{"location":"compatibility/#differences","title":"Differences","text":"<p>Here are a list of things that are incompatible:</p> <ol> <li> <p>The <code>data</code> input for <code>Backtest</code> should be a dataframe with 2-level column index. For example,      <pre><code>$ print(self.data)\n\n           AAPL                              GOOG \n           Open  High  Low   Close Volume    Open  High  Low   Close Volume\nDate          \n2018-01-02 40.39 40.90 40.18 40.89 102223600 52.42 53.35 52.26 53.25 24752000\n2018-01-03 40.95 41.43 40.82 40.88 118071600 53.22 54.31 53.16 54.12 28604000\n2018-01-04 40.95 41.18 40.85 41.07 89738400 54.40 54.68 54.20 54.32 20092000\n2018-01-05 41.17 41.63 41.08 41.54 94640000 54.70 55.21 54.60 55.11 25582000\n2018-01-08 41.38 41.68 41.28 41.38 82271200 55.11 55.56 55.08 55.35 20952000\n</code></pre>     For single asset, <code>data</code>, as a single level column DataFrame, still works. Since asset name is not specified, it's default to \"Asset\".     <pre><code>$ print(self.data)\n\n           Open  High  Low   Close Volume \nDate          \n2018-01-02 40.39 40.90 40.18 40.89 102223600 \n2018-01-03 40.95 41.43 40.82 40.88 118071600 \n2018-01-04 40.95 41.18 40.85 41.07 89738400 \n2018-01-05 41.17 41.63 41.08 41.54 94640000 \n2018-01-08 41.38 41.68 41.28 41.38 82271200 \n</code></pre>     Minitrade expects <code>Volume</code> data to be always avaiable. <code>data</code> should be consisted of OHLCV.</p> </li> <li> <p>Calling <code>Strategy.next()</code> starts on the first bar when all data and indicators become available, in contrast to on the 2nd bar as implemented in the original library. This will likely change backtest result.</p> </li> <li> <p><code>Strategy.position</code> is no longer a property, but a function of signature    <pre><code>def position(ticker=None):\n</code></pre> <code>ticker</code> can be omitted in single asset strategies. <code>self.position</code> should be changed to <code>self.position()</code> in strategy code.</p> </li> <li> <p><code>Strategy.trades</code> is no longer a property, but a function of signature    <pre><code>def trades(ticker=None):\n</code></pre> <code>ticker</code> can be omitted in single asset strategies. <code>self.trades</code> should be changed to <code>self.trades()</code> in strategy code.</p> </li> <li> <p><code>Trade.value</code> is no longer the absolute value of the trade. It's a signed value that can be negative for short trade. </p> </li> <li> <p><code>Strategy.orders</code> returns a plain <code>List[Order]</code>. If <code>self.orders.cancel()</code> is used with a semantic meaning of \"Cancel all non-contingent (i.e. SL/TP) orders.\", it should be replaced with the following explicitly.</p> <pre><code>for order in self.orders:\n    if not order.is_contingent:\n        order.cancel()\n</code></pre> </li> <li> <p>Pandas DataFrame and Series have richer APIs to work with, and therefore, are preferred over Numpy arrays when defining indicators in <code>Strategy.init()</code>. <code>Strategy.I()</code> returns Pandas objects. <code>Strategy._indicators</code> holds a list of Pandas objects rather than Numpy arrays. Variables derived from an indicator are no longer automatically added as indicators. Explicitly wrap in <code>I()</code> to define new indicators. For example,</p> <pre><code>self.sma = self.I(SMA, self.data.Close, 10)             # defines an indicator\nself.not_a_indicator = np.cumsum(self.sma * 5 + 1)      # not an indicator\nself.a_indicator = self.I(np.cumsum(self.sma * 5 + 1))  # another indicator\n</code></pre> </li> <li> <p><code>Strategy.I()</code> takes both function and value arguments. With <code>self.data.ta</code> accessor, it's easier to precompute the indicator value then wrap it in <code>I()</code> than to present as a function call. For example, the following is equivalent, but the former is visually simpler.</p> <pre><code>self.sma = self.I(self.data.ta.sma(self.n_sma))         #1\nself.sma = self.I(ta.SMA, self.data.Close, self.n_sma)  #2\n</code></pre> </li> <li> <p>Since indexing of Numpy array is much faster than that of Pandas objects, indicators in <code>Strategy.next()</code> context are returned as Numpy arrays by default. Use <code>.df</code> to access the Pandas value, either as DataFrame or Series, of the indicator. It's the caller's reponsibility to keep track of which exact type should be returned. <code>.s</code> accessor is also available but only as a syntax suger to return a Series. If the actual data is a DataFrame, <code>.s</code> throws a <code>ValueError</code>.</p> </li> <li> <p>Comparing indicators directly is no longer supported. Be explicit of what you want to compare, for example, </p> <p><pre><code>if self.data.Close &gt; self.sma:          # no longer work\nif self.data.Close[-1] &gt; self.sma[-1]:  # use indexing explicitly\n</code></pre> Similarly, use indicators directly in a boolean context is not longer supported.  <pre><code>if self.doji:                              # no longer work\nif bool(self.doji[-1]):                 # use indexing and conversion explicitly\n</code></pre></p> </li> <li> <p><code>Backtest</code> now has an extra argument <code>fail_fast</code> default to <code>True</code>, which means backtest will abort whenever an error occurs, e.g. cash is not enough to cover intended orders. This is to detect issues early in a live trading environment. If it's not desired in backtesting, set it to <code>False</code>.</p> </li> <li> <p>There are some changes to the default values for plotting. <code>plot_volume</code> and <code>superimpose</code> are <code>False</code> by default. Minitrade doesn't try to guess where to plot the indicators. So to overlay the indicators on the main chart, set <code>overlay=True</code> explicitly.</p> </li> </ol>"},{"location":"compatibility/#examples","title":"Examples","text":"<p>The following notebooks from Backtesting.py are adapted to show how to make them work with Minitrade. Only the code part is changed, the text content may or may not apply to Minitrade. </p> <ul> <li>Quick Start User Guide</li> <li>Strategies Librry</li> <li>Multiple Time Frames</li> <li>Parameter Heatmap &amp; Optimization</li> <li>Trading with Machine Learning</li> </ul>"},{"location":"contributing/","title":"How to contribute","text":"<p>I'm really glad you're reading this. While I develope this package for my personal use, I am happy to see it be useful for more people. </p> <p>Here are a few things I'd like to do but probably can't with my limited usage scenarios and resoruces:</p> <ol> <li>Enable the backtesting and trading of broader strategies </li> <li>Support more data sources</li> <li>Integrate with more brokers</li> <li>Better execution control, override, and error handling</li> <li>Better strategy performance analysis and visualization</li> <li>More examples and documentation</li> <li>Support more operating systems</li> <li>Other interesting ideas</li> </ol> <p>Minitrade is built on top of <code>Backtesting.py</code>. If you contribute to <code>Backtesting.py</code>, it's likely the improvoment will find its way into Minitrade. So contribute there if applicable, which helps both projects. If it's more relevant to Minitrade, feel free to contribute here.</p> <p>Finally, I'd love your feedback on your experience using Minitrade. Let me know in Discussions.</p> <p>Thanks.</p>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#hardware-requirements","title":"Hardware requirements","text":"<p>Minitrade is designed to operate efficiently on resource-constrained environments, such as AWS Lightsail instances with modest specifications: 1 GB RAM, 1 vCPU, and 40 GB SSD, which typically cost $5 per month. To optimize performance on such machines, it is advisable to allocate an additional 1 GB of swap space. Detailed instructions for adding swap space on Ubuntu 20.04, or similar operating systems, can be found in this guide.</p>"},{"location":"install/#security-recommendations","title":"Security recommendations","text":"<p>Ensuring server access security is paramount, especially considering the sensitive broker credentials stored locally. Here are key security recommendations:</p> <ul> <li>Dedicated Server: Employ a dedicated server exclusively for Minitrade operations to mitigate risks associated with mixed-purpose instances.</li> <li>Secure Remote Access: Use OpenVPN or similar technology for secure remote server access, safeguarding against unauthorized entry.</li> <li>Firewall Configuration: Configure firewall rules to permit only SSH and OpenVPN connections. Utilize firewall rules to block remote access to the Minitrade web UI and IB gateway, only allow local access to the web UI via a private IP address over OpenVPN connection.</li> <li>Dedicated IB User: Establish a dedicated IB user for Minitrade. This user should be granted only essential trading access while disallowing other privileges to prevent conflicts and minimize account permissions.</li> </ul>"},{"location":"install/#try-in-docker","title":"Try in docker","text":"<p>While running Minitrade within a Docker container is generally discouraged due to resource utilization and management complexities, it can serve as a viable option for experimentation. If you opt to proceed with this approach, adhere to the following steps:</p> <ol> <li>Build Docker Image: Begin by constructing a Docker image using the provided Dockerfile.</li> <li>Port Exposure: Ensure port 8501 is exposed to facilitate access to the web UI.</li> <li>Platform Compatibility: Note that the Docker image has been primarily tested on Linux hosts. It may encounter compatibility issues on Mac systems equipped with M1/M2 chips, particularly due to Chrome compatibility concerns.</li> <li>Configuration Modifications: Should modifications be made to the telegram or email settings, it's imperative to restart the container to enact these changes effectively.</li> </ol>"},{"location":"install/#install-on-ubuntu-2004","title":"Install on Ubuntu 20.04","text":"<ol> <li> <p>Install OpenVPN: Follow the instructions provided here to set up OpenVPN. Ensure that the firewall allows traffic on the port OpenVPN listens on.</p> </li> <li> <p>Install pyenv: Refer to the instructions outlined here to install pyenv. Once installed, proceed to install Python 3.10:</p> <pre><code>pyenv install 3.11.8\npyenv global 3.11.8\n</code></pre> </li> <li> <p>Install Dependencies:</p> <pre><code>sudo apt install -y default-jre\nwget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add - \nsudo sh -c 'echo \"deb https://dl.google.com/linux/chrome/deb/ stable main\" &gt;&gt; /etc/apt/sources.list.d/google.list'\nsudo apt update\nsudo apt install -y google-chrome-stable\n</code></pre> </li> <li> <p>Install Minitrade:</p> <pre><code>pip install minitrade\nminitrade init\n</code></pre> </li> </ol>"},{"location":"install/#install-on-ubuntu-2204","title":"Install on Ubuntu 22.04","text":"<ol> <li> <p>Install OpenVPN: Follow the instructions provided here to set up OpenVPN. Ensure that the firewall allows traffic on the port OpenVPN listens on.</p> </li> <li> <p>Install Python 3.10:</p> <pre><code>sudo apt update\nsudo apt install -y python3.10 wget gnupg\nsudo ln -s /usr/bin/python3.10 /usr/bin/python\nwget https://bootstrap.pypa.io/get-pip.py\nsudo python get-pip.py\n</code></pre> </li> <li> <p>Install Dependencies:</p> <pre><code>sudo apt install -y default-jre\nwget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add - \nsudo sh -c 'echo \"deb https://dl.google.com/linux/chrome/deb/ stable main\" &gt;&gt; /etc/apt/sources.list.d/google.list'\nsudo apt update\nsudo apt install -y google-chrome-stable\n</code></pre> </li> <li> <p>Install Minitrade:</p> <pre><code>pip install minitrade\nminitrade init\n</code></pre> </li> </ol>"},{"location":"install/#launch-minitrade","title":"Launch Minitrade","text":"<p>Launching Minitrade involves starting all three processes:</p> <pre><code># Start the scheduler\nminitrade scheduler start\n\n# Start IB Gateway\nminitrade ib start \n\n# Start the web UI\nminitrade web start\n</code></pre> <p>For long-term process management, consider using a process monitor like Supervisor. Alternatively, you can use this script for a quick and simple launch.</p>"},{"location":"trading/","title":"Trading","text":"<p>Trading a strategy manually is demanding. Running backtest, submitting orders, adhering to the plan despite ups and downs in the market, and monitoring performance takes not only effort, but also discipline. Minitrade makes it easy by automating the entire process.</p> <p>The trading system provided by Minitrade comprises three modules:</p> <ol> <li>Scheduler: This module runs strategies at regular intervals and handles order submissions.</li> <li>Broker Gateway: The broker gateway module serves as an interface between Minitrade and the broker system, specifically Interactive Brokers (IB), facilitating seamless communication.</li> <li>Web UI: Minitrade's web user interface allows users to manage trading plans and monitor the execution of trades.</li> </ol>"},{"location":"trading/#launch","title":"Launch","text":"<p>Launch Minitrade with the following commands:</p> <pre><code># start scheduler\nminitrade scheduler start\n\n# start ibgateway\nminitrade ib start \n\n# start web UI\nminitrade web start\n</code></pre> <p>You can also manage Minitrade using the script.</p> <p>The web UI can be accessed at: <code>http://127.0.0.1:8501</code></p> <p></p> <p></p>"},{"location":"trading/#configure","title":"Configure","text":"<p>Configuring the system takes a few steps:</p> <ol> <li> <p>Telegram bot (required)</p> <p>Configure a Telegram bot to receive notifications and to control trader execution. It's important to do this first since setting up brokers relies on this to be functional. Follow the instructions to create a bot, and take note of the token and chat ID. Configure those in web UI. On saving the configuration, a test message will be sent. Setup is successful if the message can be received.</p> <p>After changing telegram settings, restart all Minitrade processes to make the change effective.</p> </li> <li> <p>Email provider (optional)</p> <p>Configure a Mailjet account to receive email notifcations about backtesting and trading results. A free-tier account should be enough. Configure authorized senders in Mailjet, otherwise sending will fail. Try use different domains for senders and receivers if free email services like Hotmail, Gmail are used, otherwise, e.g., an email sending from a Hotmail address, through 3rd part servers, to the same or another Hotmail address is likely to be treated as spam and not delivered. Sending from Hotmail address to Gmail address or vice versa increases the chance of going through. On saving the configuration, a test email will be sent. Setup is successful if the email can be received.</p> <p>After changing email settings, restart all Minitrade processes to make the change effective.</p> </li> <li> <p>Data source</p> <p>Test the data source and make sure it works. Currently Yahoo and EasyMoney are supported. If accessing Yahoo requires a proxy, configure it in the web UI. </p> </li> <li> <p>Broker</p> <p>The \"Manual\" broker allows for automated backtesting and manual order placement.</p> <p>To set up InteractiveBrokers, enter the username, password, and assign an alias to the account. The selected \"Account type\" is merely a reminder and does not determine whether it is a paper or live account.</p> <p>Before saving the account, a test connection is made to verify the correctness of the credentials and establish a successful connection. For InteractiveBrokers, if two-factor authentication is enabled, pay attention to Telegram notifications to complete the login process. </p> <p>The credentials are stored in a local database. Ensure that server access is properly secured.</p> <p></p> </li> <li> <p>Strategy</p> <p>Strategies are Python files that contain a strategy class, which should inherit from the <code>Strategy</code> class. These files can be uploaded through the UI and be made available for defining a trade plan. If a strategy class cannot be found in the uploaded file, an error will be displayed. In case there are multiple strategy classes in a file, the one intended to be executed should be decorated with @entry_strategy. To update a strategy, upload a different file with the same filename.</p> </li> <li> <p>Trade plan</p> <p>A trade plan encompasses essential information for executing a strategy, including:</p> <ul> <li>Specifying the strategy to be executed.</li> <li>Providing a list of tickers that make up the asset universe.</li> <li>Selecting the data source for price data.</li> <li>Setting the starting date for backtesting.</li> <li>Determining the date from which trade orders should be generated.</li> <li>Scheduling the time of day for running the backtest.</li> <li>Assigning the broker account for order submission.</li> <li>Defining the initial cash investment and asset holdings.</li> </ul> <p>After defining the trade plan, a test backtest dry run will be initiated. This dry run should finish error-free but will not generate any actual orders.</p> <p>Upon successful completion of the test run, the trade plan will be scheduled to execute on every market trading day at the specified time.</p> <p>Backtesting and trading functionalities can be enabled or disabled through the web UI.</p> </li> </ol>"},{"location":"trading/#how-trading-works","title":"How trading works","text":"<p>Defining a trade plan requires various inputs as depicted in the following image.</p> <p></p>"},{"location":"trading/#broker-account","title":"Broker account","text":"<p>Specify the broker account to be used for order placement. If you have configured an InteractiveBrokers account, it will be set as the default option. Alternatively, you can choose the built-in \"Manual\" account. With the \"Manual\" account, Minitrade automatically runs backtests at scheduled intervals and generates raw orders. However, it's your responsibility to place the orders through your broker's system, which is beyond the control of Minitrade. You can input the actual trade prices into Minitrade to track the performance of your strategy.</p>"},{"location":"trading/#asset-space","title":"Asset space","text":"<p>Specify the universe of assets for your strategy. For a single-asset strategy, enter a single symbol. For a multi-asset strategy, provide a comma-separated list of symbols. Please note that the generic stock symbol we commonly use may not represent the actual tradable asset recognized by the broker. InteractiveBrokers uses a contract ID to uniquely identify tradable assets. For example, the symbol \"AAPL\" can correspond to different contracts:</p> <p><pre><code>APPLE INC {'conid': 265598, 'exchange': 'NASDAQ', 'isUS': True}\nLS 1X AAPL {'conid': 493546048, 'exchange': 'LSEETF', 'isUS': False}\nAPPLE INC-CDR {'conid': 532640894, 'exchange': 'AEQLIT', 'isUS': False}\n</code></pre> Minitrade allows you to select the specific contract you wish to trade. The process of mapping a generic symbol to a broker-specific contract ID requires an active connection to the broker. If a connection is not already established, Minitrade will initiate one. Please pay attention to Telegram notifications on your mobile device after filling in this field.</p>"},{"location":"trading/#data-source","title":"Data source","text":"<p>Choose the desired data source. \"Yahoo\" is recommended for U.S. markets, while \"EastMoney\" is suitable for the China market. When the market is open, \"Yahoo\" provides real-time OHLCV data until the present moment, as well as historical data for previous days.</p>"},{"location":"trading/#backtest-start-date","title":"Backtest start date","text":"<p>Specify the starting date for the backtest. Consider the lead time required by the strategy to calculate indicators. For example, if the strategy uses a 20-day Simple Moving Average (SMA), it is advisable to set the backtest start date to a month earlier from the present date. Setting the start date too far in the past unnecessarily prolongs the backtesting process.</p>"},{"location":"trading/#trade-start-date","title":"Trade start date","text":"<p>Specify the date from which the backtest should begin generating trade orders. Generating orders for dates prior to today is futile, as the opportunities to place orders have already passed. Therefore, the backtest will suppress any trade signals generated before the specified date.</p>"},{"location":"trading/#order-entry-type","title":"Order entry type","text":"<p>Specify the timing or type of an order. Three order entry types are defined:</p> <ol> <li> <p>Trade on open (TOO)</p> <p>Use this type if you want trades to happen on market open. This is a regular market order but is submitted outside of regular market hours, so that it can be executed on next market open. Make sure you run backtests outside of regular market hours.</p> </li> <li> <p>Trade on close (TOC)</p> <p>Use this type if you want trades to happen on market close. This is a market-on-close order. It should be submitted during market hours and before market close. Usually you want to schedule backtest to run a short moment before market close to capture the latest price movement.</p> </li> <li> <p>Trade regular hours (TRG)</p> <p>Use this type if you want trades to happen at earliest possible time. This is just a regular market order. If submitted during market hours, it's executed immediately. Otherwise, it's executed on next market open.</p> </li> </ol>"},{"location":"trading/#backtest-run-time","title":"Backtest run time","text":"<p>Specify when backtest should run. Backtests can be scheduled during a day using two formats: \"HH:MM:SS\" and \"HH:MM:SS-HH:MM:SS/Interval.\" For instance, \"10:00:00\" represents 10 AM, while \"9:30:01-16:00/30min\" means the backtest will run every 30 minutes during market open. You can combine both formats to define complex schedules and confirm the exact timing through a preview.</p> <p>It's important to consider the complexity of the backtest, as the duration can vary from seconds to minutes or longer. To ensure smooth execution, it is recommended to leave sufficient spacing between backtests of the same strategy or different strategies. Only one backtest runs at any given time, while others are queued. If a backtest misses its intended schedule by more than 3 minutes, it will be skipped and not run at all. Additionally, keep in mind that the exact timing of backtests at market open or market close may not be well-defined, as there can be slight clock deviations.</p> <p>Minitrade ensures that backtests are executed on every open trading day for the intended market. If you prefer to run backtests less frequently, such as rebalancing at the beginning of each month, you can handle this within the strategy itself. Utilize <code>self.broker.now</code> to retrieve the current date and skip processing if necessary.</p>"},{"location":"trading/#cash-amount","title":"Cash amount","text":"<p>Specify the amount of cash you wish to invest in the strategy as an initial investment.</p>"},{"location":"trading/#preexisting-asset-positions","title":"Preexisting asset positions","text":"<p>Specify any existing positions that you have and want to be taken into account by the strategy. For example, if you currently hold 100 shares of SPY and 100 shares of QQQ, and you want to run a strategy that rebalances between these assets on a monthly basis, you should enter \"SPY:100, QQQ:100\" in this field.</p>"},{"location":"trading/#backtest-mode","title":"Backtest mode","text":"<p>Minitrade offers two distinct backtest modes with differing assumptions. The first is \"Strict mode,\" which assumes that a backtest's outcome is replicable. In other words, if a backtest is run for a trade plan today, the results up until yesterday will be identical to a backtest run yesterday. Similarly, running the backtest tomorrow will yield the same output up until today's date. Under this mode, the backtest always uses the parameters specified in the trade plan. It assumes successful execution of orders at simulated prices, without considering if that actually happens. The accuracy of the backtest's reflection of reality relies on a number of assumptions, notably:</p> <ol> <li>Price quotes from the data source remain unchanged. This can break in cases of dividends or stock splits. Minitrade halts a backtest if it detects price changes.</li> <li>The strategy can only issue \"TOC\" or \"TOO\" orders, as their prices are deterministic and known during the backtest.</li> <li>Orders must be executed successfully.</li> </ol> <p>Over time, these assumptions will break, causing the backtest to fall out of sync with reality. When this occurs, it may be necessary to remove the trade plan and create a new one to restore synchronization. Therefore this approach requires regular maintenance. But it offers the advantage of closely aligning the actual trade performance with that of the strategy.</p> <p>Alternatively, if some deviation from the strategy is acceptable during execution, Minitrade also supports an \"incremental\" backtest mode. In this mode, the backtest follows these steps:</p> <ol> <li>Download the latest order and trade status from the broker.</li> <li>Calculate the actual positions associated with the strategy based on initial positions and executed trades.</li> <li>Cancel any unsubmitted orders tied to the strategy and any submitted orders that remain unfilled at the broker.</li> <li>Perform the backtest, replacing the cash and initial positions specified in the trade plan with the current cash and positions, and setting the trade_start_date as today.</li> <li>Submit new orders generated by the backtest.</li> </ol> <p>In the \"incremental\" mode, we assume that the strategy can consistently make correct decisions using the most recent cash and position information, irrespective of previous backtest runs. While this assumption is also strong, it is less restrictive if the strategy is properly designed to accommodate external changes. The benefit of this mode is increased robustness and reduced maintenance compared to the \"strict\" mode.</p> <p>It is important to determine which mode is appropriate for running your strategy.</p>"},{"location":"trading/#ib-gateway","title":"IB gateway","text":"<p>Minitrade utilizes IB's client portal API for order submission. The gateway client is downloaded and configured during the execution of <code>minitrade init</code>. Automated login is facilitated using Chrome and Selenium webdriver.</p> <p>IB terminates a session after approximately 24 hours. Minitrade verifies the connection status when interacting with IB, such as when submitting an order or retrieving account information via the web UI. If Minitrade initiates a connection automatically, a silent 2FA push notification is randomly sent to the user's mobile phone. This notification may be easily missed, resulting in a login failure. Multiple consecutive failed attempts may lead to an account lockout, necessitating contact with customer service to unlock the account.</p> <p>To prevent such issues, Minitrade only submits orders when a working connection to a broker is already established. If a connection does not exist, Minitrade sends notifications through a Telegram bot, informing the user of pending orders to be submitted. The user must manually issue the <code>/ib login</code> command to the bot, triggering a login to the IB account. Within a few seconds, the user should receive the 2FA push notification on their mobile phone and complete the login process. Once the login is successful, Minitrade can proceed with order submission.</p>"},{"location":"examples/Multiple%20Time%20Frames/","title":"Multiple Time Frames","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\n\n\ndef SMA(array, n):\n    \"\"\"Simple moving average\"\"\"\n    return array.rolling(n).mean()\n\n\ndef RSI(array, n):\n    \"\"\"Relative strength index\"\"\"\n    # Approximate; good enough\n    gain = array.diff()\n    loss = gain.copy()\n    gain[gain &lt; 0] = 0\n    loss[loss &gt; 0] = 0\n    rs = gain.ewm(n).mean() / loss.abs().ewm(n).mean()\n    return 100 - 100 / (1 + rs)\n</pre> import pandas as pd   def SMA(array, n):     \"\"\"Simple moving average\"\"\"     return array.rolling(n).mean()   def RSI(array, n):     \"\"\"Relative strength index\"\"\"     # Approximate; good enough     gain = array.diff()     loss = gain.copy()     gain[gain &lt; 0] = 0     loss[loss &gt; 0] = 0     rs = gain.ewm(n).mean() / loss.abs().ewm(n).mean()     return 100 - 100 / (1 + rs) <p>The strategy roughly goes like this:</p> <p>Buy a position when:</p> <ul> <li>weekly RSI(30) $\\geq$ daily RSI(30) $&gt;$ 70</li> <li>Close $&gt;$ MA(10) $&gt;$ MA(20) $&gt;$ MA(50) $&gt;$ MA(100)</li> </ul> <p>Close the position when:</p> <ul> <li>Daily close is more than 2% below MA(10)</li> <li>8% fixed stop loss is hit</li> </ul> <p>We need to provide bars data in the lowest time frame (i.e. daily) and resample it to any higher time frame (i.e. weekly) that our strategy requires.</p> In\u00a0[2]: Copied! <pre>from minitrade.backtest import Strategy, Backtest\nfrom minitrade.backtest.core.lib import resample_apply\n\n\nclass System(Strategy):\n    d_rsi = 30  # Daily RSI lookback periods\n    w_rsi = 30  # Weekly\n    level = 70\n\n    def init(self):\n        # Compute moving averages the strategy demands\n        self.ma10 = self.I(SMA, self.data.Close.df, 10)\n        self.ma20 = self.I(SMA, self.data.Close.df, 20)\n        self.ma50 = self.I(SMA, self.data.Close.df, 50)\n        self.ma100 = self.I(SMA, self.data.Close.df, 100)\n\n        # Compute daily RSI(30)\n        self.daily_rsi = self.I(RSI, self.data.Close.df, self.d_rsi)\n\n        # To construct weekly RSI, we can use `resample_apply()`\n        # helper function from the library\n        self.weekly_rsi = resample_apply('W-FRI', RSI, self.data.Close.df, self.w_rsi)\n\n    def next(self):\n        price = self.data.Close[-1]\n\n        # If we don't already have a position, and\n        # if all conditions are satisfied, enter long.\n        if (not self.position() and\n            self.daily_rsi[-1] &gt; self.level and\n            self.weekly_rsi[-1] &gt; self.level and\n            self.weekly_rsi[-1] &gt; self.daily_rsi[-1] and\n            self.ma10[-1] &gt; self.ma20[-1] &gt; self.ma50[-1] &gt; self.ma100[-1] and\n                price &gt; self.ma10[-1]):\n\n            # Buy at market price on next open, but do\n            # set 8% fixed stop loss.\n            self.buy(sl=.92 * price)\n\n        # If the price closes 2% or more below 10-day MA\n        # close the position, if any.\n        elif price &lt; .98 * self.ma10[-1]:\n            self.position().close()\n</pre> from minitrade.backtest import Strategy, Backtest from minitrade.backtest.core.lib import resample_apply   class System(Strategy):     d_rsi = 30  # Daily RSI lookback periods     w_rsi = 30  # Weekly     level = 70      def init(self):         # Compute moving averages the strategy demands         self.ma10 = self.I(SMA, self.data.Close.df, 10)         self.ma20 = self.I(SMA, self.data.Close.df, 20)         self.ma50 = self.I(SMA, self.data.Close.df, 50)         self.ma100 = self.I(SMA, self.data.Close.df, 100)          # Compute daily RSI(30)         self.daily_rsi = self.I(RSI, self.data.Close.df, self.d_rsi)          # To construct weekly RSI, we can use `resample_apply()`         # helper function from the library         self.weekly_rsi = resample_apply('W-FRI', RSI, self.data.Close.df, self.w_rsi)      def next(self):         price = self.data.Close[-1]          # If we don't already have a position, and         # if all conditions are satisfied, enter long.         if (not self.position() and             self.daily_rsi[-1] &gt; self.level and             self.weekly_rsi[-1] &gt; self.level and             self.weekly_rsi[-1] &gt; self.daily_rsi[-1] and             self.ma10[-1] &gt; self.ma20[-1] &gt; self.ma50[-1] &gt; self.ma100[-1] and                 price &gt; self.ma10[-1]):              # Buy at market price on next open, but do             # set 8% fixed stop loss.             self.buy(sl=.92 * price)          # If the price closes 2% or more below 10-day MA         # close the position, if any.         elif price &lt; .98 * self.ma10[-1]:             self.position().close() <p>Let's see how our strategy fares replayed on nine years of Google stock data.</p> In\u00a0[3]: Copied! <pre>from minitrade.backtest.core.test import GOOG\n\nbacktest = Backtest(GOOG, System, commission=.002)\nbacktest.run()\n</pre> from minitrade.backtest.core.test import GOOG  backtest = Backtest(GOOG, System, commission=.002) backtest.run() Out[3]: <pre>Start                                                   2004-08-19 00:00:00\nEnd                                                     2013-03-01 00:00:00\nDuration                                                 3116 days 00:00:00\nExposure Time [%]                                                  2.793296\nEquity Final [$]                                                10017.44422\nEquity Peak [$]                                                  10978.3801\nReturn [%]                                                         0.174442\nBuy &amp; Hold Return [%]                                            313.303599\nReturn (Ann.) [%]                                                  0.021438\nVolatility (Ann.) [%]                                              5.059486\nSharpe Ratio                                                       0.004237\nSortino Ratio                                                      0.005488\nCalmar Ratio                                                       0.002142\nMax. Drawdown [%]                                                 -10.00745\nAvg. Drawdown [%]                                                 -9.340092\nMax. Drawdown Duration                                   2653 days 00:00:00\nAvg. Drawdown Duration                                   1410 days 00:00:00\n# Trades                                                                  4\nWin Rate [%]                                                           25.0\nBest Trade [%]                                                     9.687579\nWorst Trade [%]                                                   -4.456159\nAvg. Trade [%]                                                     0.081712\nMax. Trade Duration                                        35 days 00:00:00\nAvg. Trade Duration                                        21 days 00:00:00\nProfit Factor                                                       1.10514\nExpectancy [%]                                                     0.230413\nSQN                                                                0.014232\nKelly Criterion                                                    0.004833\n_strategy                                                            System\n_equity_curve                              Equity  Asset         Cash  D...\n_trades                      EntryBar  ExitBar Ticker  Size  EntryPrice ...\n_orders                              Ticker  Side  Size\nSignalTime      ...\n_positions                                      {'Asset': 0, 'Cash': 10017}\n_trade_start_bar                                                         99\ndtype: object</pre> <p>Meager four trades in the span of nine years and with zero return? How about if we optimize the parameters a bit?</p> In\u00a0[4]: Copied! <pre>%%time\n\nbacktest.optimize(d_rsi=range(10, 35, 5),\n                  w_rsi=range(10, 35, 5),\n                  level=range(30, 80, 10))\n</pre> %%time  backtest.optimize(d_rsi=range(10, 35, 5),                   w_rsi=range(10, 35, 5),                   level=range(30, 80, 10)) <pre>/Users/ww/workspace/minitrade/minitrade/backtest/core/backtesting.py:2248: UserWarning: For multiprocessing support in `Backtest.optimize()` set multiprocessing start method to 'fork'.\n  warnings.warn(\"For multiprocessing support in `Backtest.optimize()` \"\n</pre> <pre>  0%|          | 0/9 [00:00&lt;?, ?it/s]</pre> <pre>CPU times: user 5.2 s, sys: 35.6 ms, total: 5.23 s\nWall time: 5.3 s\n</pre> Out[4]: <pre>Start                                                   2004-08-19 00:00:00\nEnd                                                     2013-03-01 00:00:00\nDuration                                                 3116 days 00:00:00\nExposure Time [%]                                                 22.486034\nEquity Final [$]                                                22822.75224\nEquity Peak [$]                                                 23395.59144\nReturn [%]                                                       128.227522\nBuy &amp; Hold Return [%]                                            313.303599\nReturn (Ann.) [%]                                                 10.681374\nVolatility (Ann.) [%]                                             13.518924\nSharpe Ratio                                                       0.790105\nSortino Ratio                                                      1.338786\nCalmar Ratio                                                       0.564533\nMax. Drawdown [%]                                                -18.920719\nAvg. Drawdown [%]                                                 -3.795058\nMax. Drawdown Duration                                    778 days 00:00:00\nAvg. Drawdown Duration                                     97 days 00:00:00\n# Trades                                                                 23\nWin Rate [%]                                                      65.217391\nBest Trade [%]                                                    25.034669\nWorst Trade [%]                                                   -6.297769\nAvg. Trade [%]                                                     3.705482\nMax. Trade Duration                                        63 days 00:00:00\nAvg. Trade Duration                                        29 days 00:00:00\nProfit Factor                                                      5.024416\nExpectancy [%]                                                     3.971489\nSQN                                                                 2.63967\nKelly Criterion                                                    0.515784\n_strategy                                System(d_rsi=30,w_rsi=10,level=60)\n_equity_curve                              Equity     Asset         Cash...\n_trades                       EntryBar  ExitBar Ticker  Size  EntryPrice...\n_orders                              Ticker  Side  Size\nSignalTime      ...\n_positions                                       {'Asset': 28, 'Cash': 249}\n_trade_start_bar                                                         99\ndtype: object</pre> In\u00a0[5]: Copied! <pre>backtest.plot()\n</pre> backtest.plot() <pre>/Users/ww/workspace/minitrade/minitrade/backtest/core/_plotting.py:737: UserWarning: found multiple competing values for 'toolbar.active_drag' property; using the latest value\n  fig = gridplot(\n/Users/ww/workspace/minitrade/minitrade/backtest/core/_plotting.py:737: UserWarning: found multiple competing values for 'toolbar.active_scroll' property; using the latest value\n  fig = gridplot(\n</pre> Out[5]: GridPlot(id\u00a0=\u00a0'p1523', \u2026)align\u00a0=\u00a0'auto',aspect_ratio\u00a0=\u00a0None,children\u00a0=\u00a0[(figure(id='p1046', ...), 0, 0), (figure(id='p1155', ...), 1, 0), (figure(id='p1002', ...), 2, 0), (figure(id='p1240', ...), 3, 0), (figure(id='p1285', ...), 4, 0), (figure(id='p1330', ...), 5, 0), (figure(id='p1375', ...), 6, 0), (figure(id='p1420', ...), 7, 0), (figure(id='p1466', ...), 8, 0)],cols\u00a0=\u00a0None,context_menu\u00a0=\u00a0None,css_classes\u00a0=\u00a0[],disabled\u00a0=\u00a0False,flow_mode\u00a0=\u00a0'block',height\u00a0=\u00a0None,height_policy\u00a0=\u00a0'auto',js_event_callbacks\u00a0=\u00a0{},js_property_callbacks\u00a0=\u00a0{},margin\u00a0=\u00a0None,max_height\u00a0=\u00a0None,max_width\u00a0=\u00a0None,min_height\u00a0=\u00a0None,min_width\u00a0=\u00a0None,name\u00a0=\u00a0None,resizable\u00a0=\u00a0False,rows\u00a0=\u00a0None,sizing_mode\u00a0=\u00a0'stretch_width',spacing\u00a0=\u00a00,styles\u00a0=\u00a0{},stylesheets\u00a0=\u00a0[],subscribed_events\u00a0=\u00a0PropertyValueSet(),syncable\u00a0=\u00a0True,tags\u00a0=\u00a0[],toolbar\u00a0=\u00a0Toolbar(id='p1522', ...),toolbar_location\u00a0=\u00a0'right',visible\u00a0=\u00a0True,width\u00a0=\u00a0None,width_policy\u00a0=\u00a0'auto') <p>Better. While the strategy doesn't perform as well as simple buy &amp; hold, it does so with significantly lower exposure (time in market).</p> <p>In conclusion, to test strategies on multiple time frames, you need to pass in OHLC data in the lowest time frame, then resample it to higher time frames, apply the indicators, then resample back to the lower time frame, filling in the in-betweens. Which is what the function <code>backtesting.lib.resample_apply()</code> does for you.</p> <p>Learn more by exploring further examples or find more framework options in the full API reference.</p>"},{"location":"examples/Multiple%20Time%20Frames/#multiple-time-frames","title":"Multiple Time Frames\u00b6","text":"<p>Best trading strategies that rely on technical analysis might take into account price action on multiple time frames. This tutorial will show how to do that with backtesting.py, offloading most of the work to pandas resampling. It is assumed you're already familiar with basic framework usage.</p> <p>We will put to the test this long-only, supposed 400%-a-year trading strategy, which uses daily and weekly relative strength index (RSI) values and moving averages (MA).</p> <p>In practice, one should use functions from an indicator library, such as TA-Lib or Tulipy, but among us, let's introduce the two indicators we'll be using.</p>"},{"location":"examples/Parameter%20Heatmap%20%26%20Optimization/","title":"Parameter Heatmap","text":"In\u00a0[1]: Copied! <pre>from minitrade.backtest.core.test import SMA\n</pre> from minitrade.backtest.core.test import SMA <p>Our strategy will be a similar moving average cross-over strategy to the one in Quick Start User Guide, but we will use four moving averages in total: two moving averages whose relationship determines a general trend (we only trade long when the shorter MA is above the longer one, and vice versa), and two moving averages whose cross-over with daily close prices determine the signal to enter or exit the position.</p> In\u00a0[2]: Copied! <pre>from minitrade.backtest import Strategy\nfrom minitrade.backtest.core.lib import crossover\n\n\nclass Sma4Cross(Strategy):\n    n1 = 50\n    n2 = 100\n    n_enter = 20\n    n_exit = 10\n    \n    def init(self):\n        self.sma1 = self.I(SMA, self.data.Close.df, self.n1)\n        self.sma2 = self.I(SMA, self.data.Close.df, self.n2)\n        self.sma_enter = self.I(SMA, self.data.Close.df, self.n_enter)\n        self.sma_exit = self.I(SMA, self.data.Close.df, self.n_exit)\n        \n    def next(self):\n        \n        if not self.position():\n            \n            # On upwards trend, if price closes above\n            # \"entry\" MA, go long\n            \n            # Here, even though the operands are arrays, this\n            # works by implicitly comparing the two last values\n            if self.sma1[-1] &gt; self.sma2[-1]:\n                if crossover(self.data.Close, self.sma_enter):\n                    self.buy()\n                    \n            # On downwards trend, if price closes below\n            # \"entry\" MA, go short\n            \n            else:\n                if crossover(self.sma_enter, self.data.Close):\n                    self.sell()\n        \n        # But if we already hold a position and the price\n        # closes back below (above) \"exit\" MA, close the position\n        \n        else:\n            if (self.position().is_long and\n                crossover(self.sma_exit, self.data.Close)\n                or\n                self.position().is_short and\n                crossover(self.data.Close, self.sma_exit)):\n                \n                self.position().close()\n</pre> from minitrade.backtest import Strategy from minitrade.backtest.core.lib import crossover   class Sma4Cross(Strategy):     n1 = 50     n2 = 100     n_enter = 20     n_exit = 10          def init(self):         self.sma1 = self.I(SMA, self.data.Close.df, self.n1)         self.sma2 = self.I(SMA, self.data.Close.df, self.n2)         self.sma_enter = self.I(SMA, self.data.Close.df, self.n_enter)         self.sma_exit = self.I(SMA, self.data.Close.df, self.n_exit)              def next(self):                  if not self.position():                          # On upwards trend, if price closes above             # \"entry\" MA, go long                          # Here, even though the operands are arrays, this             # works by implicitly comparing the two last values             if self.sma1[-1] &gt; self.sma2[-1]:                 if crossover(self.data.Close, self.sma_enter):                     self.buy()                                  # On downwards trend, if price closes below             # \"entry\" MA, go short                          else:                 if crossover(self.sma_enter, self.data.Close):                     self.sell()                  # But if we already hold a position and the price         # closes back below (above) \"exit\" MA, close the position                  else:             if (self.position().is_long and                 crossover(self.sma_exit, self.data.Close)                 or                 self.position().is_short and                 crossover(self.data.Close, self.sma_exit)):                                  self.position().close() <p>It's not a robust strategy, but we can optimize it.</p> <p>Grid search is an exhaustive search through a set of specified sets of values of hyperparameters. One evaluates the performance for each set of parameters and finally selects the combination that performs best.</p> <p>Let's optimize our strategy on Google stock data using randomized grid search over the parameter space, evaluating at most (approximately) 200 randomly chosen combinations:</p> In\u00a0[3]: Copied! <pre>%%time \n\nfrom minitrade.backtest import Backtest\nfrom minitrade.backtest.core.test import GOOG\n\n\nbacktest = Backtest(GOOG, Sma4Cross, commission=.002)\n\nstats, heatmap = backtest.optimize(\n    n1=range(10, 110, 10),\n    n2=range(20, 210, 20),\n    n_enter=range(15, 35, 5),\n    n_exit=range(10, 25, 5),\n    constraint=lambda p: p.n_exit &lt; p.n_enter &lt; p.n1 &lt; p.n2,\n    maximize='Equity Final [$]',\n    max_tries=200,\n    random_state=0,\n    return_heatmap=True)\n</pre> %%time   from minitrade.backtest import Backtest from minitrade.backtest.core.test import GOOG   backtest = Backtest(GOOG, Sma4Cross, commission=.002)  stats, heatmap = backtest.optimize(     n1=range(10, 110, 10),     n2=range(20, 210, 20),     n_enter=range(15, 35, 5),     n_exit=range(10, 25, 5),     constraint=lambda p: p.n_exit &lt; p.n_enter &lt; p.n1 &lt; p.n2,     maximize='Equity Final [$]',     max_tries=200,     random_state=0,     return_heatmap=True) <pre>/Users/ww/workspace/minitrade/minitrade/backtest/core/backtesting.py:2248: UserWarning: For multiprocessing support in `Backtest.optimize()` set multiprocessing start method to 'fork'.\n  warnings.warn(\"For multiprocessing support in `Backtest.optimize()` \"\n</pre> <pre>  0%|          | 0/9 [00:00&lt;?, ?it/s]</pre> <pre>CPU times: user 6.47 s, sys: 38.4 ms, total: 6.51 s\nWall time: 6.55 s\n</pre> <p>Notice <code>return_heatmap=True</code> parameter passed to <code>Backtest.optimize()</code>. It makes the function return a heatmap series along with the usual stats of the best run. <code>heatmap</code> is a pandas Series indexed with a MultiIndex, a cartesian product of all permissible (tried) parameter values. The series values are from the <code>maximize=</code> argument we provided.</p> In\u00a0[4]: Copied! <pre>heatmap\n</pre> heatmap Out[4]: <pre>n1   n2   n_enter  n_exit\n20   60   15       10         9780.10498\n     80   15       10         9864.21924\n     100  15       10        11003.21764\n30   40   20       15        11888.74610\n          25       15        16346.34842\n                                ...     \n100  200  15       10        13118.24766\n          20       10        11308.46180\n                   15        16518.74380\n          25       10         8991.55294\n          30       10         9953.07010\nName: Equity Final [$], Length: 177, dtype: float64</pre> <p>This heatmap contains the results of all the runs, making it very easy to obtain parameter combinations for e.g. three best runs:</p> In\u00a0[5]: Copied! <pre>heatmap.sort_values().iloc[-3:]\n</pre> heatmap.sort_values().iloc[-3:] Out[5]: <pre>n1   n2   n_enter  n_exit\n40   140  20       15        18296.45394\n100  160  20       15        19417.90456\n50   160  20       15        19767.05222\nName: Equity Final [$], dtype: float64</pre> <p>But we use vision to make judgements on larger data sets much faster. Let's plot the whole heatmap by projecting it on two chosen dimensions. Say we're mostly interested in how parameters <code>n1</code> and <code>n2</code>, on average, affect the outcome.</p> In\u00a0[6]: Copied! <pre>hm = heatmap.groupby(['n1', 'n2']).mean().unstack()\nhm\n</pre> hm = heatmap.groupby(['n1', 'n2']).mean().unstack() hm Out[6]: n2 40 60 80 100 120 140 160 180 200 n1 20 NaN 9780.104980 9864.219240 11003.217640 NaN NaN NaN NaN NaN 30 14117.54726 11656.102327 11833.501340 15248.209270 13286.483360 11598.391895 11271.353850 11449.573465 10717.850688 40 NaN 13462.739695 NaN 7624.609980 10696.599030 12991.038870 11438.851153 10935.961380 10718.967365 50 NaN 8467.364960 10180.502548 10563.790150 9149.067013 14351.970500 13653.468355 11458.974993 10128.978620 60 NaN NaN 9232.415117 8046.485900 10838.454280 12929.726093 10416.431300 9519.835100 9611.335367 70 NaN NaN 14712.143280 7192.892540 10461.744630 10165.959860 8355.260353 9950.317090 9435.988292 80 NaN NaN NaN 10909.253515 7746.413967 9190.286300 8883.167490 10478.420200 8979.801500 90 NaN NaN NaN 9050.433200 9578.601733 9884.415550 9782.404510 11385.593830 8844.327300 100 NaN NaN NaN NaN 11306.293220 7154.397113 11419.912430 10222.051700 11978.015260 <p>Let's plot this table using the excellent Seaborn package:</p> In\u00a0[7]: Copied! <pre>%matplotlib inline\n\nimport seaborn as sns\n\n\nsns.heatmap(hm[::-1], cmap='viridis')\n</pre> %matplotlib inline  import seaborn as sns   sns.heatmap(hm[::-1], cmap='viridis') Out[7]: <pre>&lt;Axes: xlabel='n2', ylabel='n1'&gt;</pre> <p>We see that, on average, we obtain the highest result using trend-determining parameters <code>n1=40</code> and <code>n2=60</code>, and it's not like other nearby combinations work similarly well \u2014 in our particular strategy, this combination really stands out.</p> <p>Since our strategy contains several parameters, we might be interested in other relationships between their values. We can use <code>backtesting.lib.plot_heatmaps()</code> function to plot interactive heatmaps of all parameter combinations simultaneously.</p> In\u00a0[8]: Copied! <pre>from minitrade.backtest.core.lib import plot_heatmaps\n\n\nplot_heatmaps(heatmap, agg='mean')\n</pre> from minitrade.backtest.core.lib import plot_heatmaps   plot_heatmaps(heatmap, agg='mean') Out[8]: GridPlot(id\u00a0=\u00a0'p1270', \u2026)align\u00a0=\u00a0'auto',aspect_ratio\u00a0=\u00a0None,children\u00a0=\u00a0[(figure(id='p1002', ...), 0, 0), (figure(id='p1046', ...), 0, 1), (figure(id='p1090', ...), 0, 2), (figure(id='p1134', ...), 1, 0), (figure(id='p1178', ...), 1, 1), (figure(id='p1222', ...), 1, 2)],cols\u00a0=\u00a0None,context_menu\u00a0=\u00a0None,css_classes\u00a0=\u00a0[],disabled\u00a0=\u00a0False,flow_mode\u00a0=\u00a0'block',height\u00a0=\u00a0None,height_policy\u00a0=\u00a0'auto',js_event_callbacks\u00a0=\u00a0{},js_property_callbacks\u00a0=\u00a0{},margin\u00a0=\u00a0None,max_height\u00a0=\u00a0None,max_width\u00a0=\u00a0None,min_height\u00a0=\u00a0None,min_width\u00a0=\u00a0None,name\u00a0=\u00a0None,resizable\u00a0=\u00a0False,rows\u00a0=\u00a0None,sizing_mode\u00a0=\u00a0None,spacing\u00a0=\u00a00,styles\u00a0=\u00a0{},stylesheets\u00a0=\u00a0[],subscribed_events\u00a0=\u00a0PropertyValueSet(),syncable\u00a0=\u00a0True,tags\u00a0=\u00a0[],toolbar\u00a0=\u00a0Toolbar(id='p1269', ...),toolbar_location\u00a0=\u00a0'above',visible\u00a0=\u00a0True,width\u00a0=\u00a0None,width_policy\u00a0=\u00a0'auto') In\u00a0[9]: Copied! <pre>%%capture\n\n# Use the forked version from https://github.com/dodid/scikit-optimize.git, which contains numpy and scikit-learn fixes.\n# ! pip install scikit-optimize  # This is a run-time dependency\n</pre> %%capture  # Use the forked version from https://github.com/dodid/scikit-optimize.git, which contains numpy and scikit-learn fixes. # ! pip install scikit-optimize  # This is a run-time dependency In\u00a0[10]: Copied! <pre>%%time\n\nstats_skopt, heatmap, optimize_result = backtest.optimize(\n    n1=[10, 100],      # Note: For method=\"skopt\", we\n    n2=[20, 200],      # only need interval end-points\n    n_enter=[10, 40],\n    n_exit=[10, 30],\n    constraint=lambda p: p.n_exit &lt; p.n_enter &lt; p.n1 &lt; p.n2,\n    maximize='Equity Final [$]',\n    method='skopt',\n    max_tries=200,\n    random_state=0,\n    return_heatmap=True,\n    return_optimization=True)\n</pre> %%time  stats_skopt, heatmap, optimize_result = backtest.optimize(     n1=[10, 100],      # Note: For method=\"skopt\", we     n2=[20, 200],      # only need interval end-points     n_enter=[10, 40],     n_exit=[10, 30],     constraint=lambda p: p.n_exit &lt; p.n_enter &lt; p.n1 &lt; p.n2,     maximize='Equity Final [$]',     method='skopt',     max_tries=200,     random_state=0,     return_heatmap=True,     return_optimization=True) <pre>Backtest.optimize:   0%|          | 0/200 [00:00&lt;?, ?it/s]</pre> <pre>CPU times: user 10.5 s, sys: 93.8 ms, total: 10.6 s\nWall time: 10.7 s\n</pre> In\u00a0[11]: Copied! <pre>heatmap.sort_values().iloc[-3:]\n</pre> heatmap.sort_values().iloc[-3:] Out[11]: <pre>n1  n2   n_enter  n_exit\n68  96   29       24        28424.01724\n35  98   28       24        28658.79512\n44  134  39       27        30251.80700\nName: Equity Final [$], dtype: float64</pre> <p>Notice how the optimization runs somewhat slower even though <code>max_tries=</code> is the same. But that's due to the sequential nature of the algorithm and should actually perform rather comparably even in cases of much larger parameter spaces where grid search would effectively blow up, but likely (hopefully) reaching a better local optimum than a randomized search would. A note of warning, again, to take steps to avoid overfitting insofar as possible.</p> <p>Understanding the impact of each parameter on the computed objective function is easy in two dimensions, but as the number of dimensions grows, partial dependency plots are increasingly useful. Plotting tools from scikit-optimize take care of many of the more mundane things needed to make good and informative plots of the parameter space:</p> In\u00a0[12]: Copied! <pre>from skopt.plots import plot_objective\n\n_ = plot_objective(optimize_result, n_points=10)\n</pre> from skopt.plots import plot_objective  _ = plot_objective(optimize_result, n_points=10) In\u00a0[13]: Copied! <pre>from skopt.plots import plot_evaluations\n\n_ = plot_evaluations(optimize_result, bins=10)\n</pre> from skopt.plots import plot_evaluations  _ = plot_evaluations(optimize_result, bins=10) <p>Learn more by exploring further examples or find more framework options in the full API reference.</p>"},{"location":"examples/Parameter%20Heatmap%20%26%20Optimization/#parameter-heatmap","title":"Parameter Heatmap\u00b6","text":"<p>This tutorial will show how to optimize strategies with multiple parameters and how to examine and reason about optimization results. It is assumed you're already familiar with basic backtesting.py usage.</p> <p>First, let's again import our helper moving average function. In practice, one should use functions from an indicator library, such as TA-Lib or Tulipy.</p>"},{"location":"examples/Parameter%20Heatmap%20%26%20Optimization/#model-based-optimization","title":"Model-based optimization\u00b6","text":"<p>Above, we used randomized grid search optimization method. Any kind of grid search, however, might be computationally expensive for large data sets. In the follwing example, we will use scikit-optimize package to guide our optimization better informed using forests of decision trees. The hyperparameter model is sequentially improved by evaluating the expensive function (the backtest) at the next best point, thereby hopefully converging to a set of optimal parameters with as few evaluations as possible.</p> <p>So, with <code>method=\"skopt\"</code>:</p>"},{"location":"examples/Quick%20Start%20User%20Guide/","title":"Backtesting.py Quick Start User Guide","text":"In\u00a0[1]: Copied! <pre># Example OHLC daily data for Google Inc.\nfrom minitrade.backtest.core.test import GOOG\n\nGOOG.tail()\n</pre> # Example OHLC daily data for Google Inc. from minitrade.backtest.core.test import GOOG  GOOG.tail() Out[1]: Open High Low Close Volume 2013-02-25 802.3 808.41 790.49 790.77 2303900 2013-02-26 795.0 795.95 784.40 790.13 2202500 2013-02-27 794.8 804.75 791.11 799.78 2026100 2013-02-28 801.1 806.99 801.03 801.20 2265800 2013-03-01 797.8 807.14 796.15 806.19 2175400 In\u00a0[2]: Copied! <pre>import pandas as pd\n\n\ndef SMA(values, n):\n    \"\"\"\n    Return simple moving average of `values`, at\n    each step taking into account `n` previous values.\n    \"\"\"\n    return values.rolling(n).mean()\n</pre> import pandas as pd   def SMA(values, n):     \"\"\"     Return simple moving average of `values`, at     each step taking into account `n` previous values.     \"\"\"     return values.rolling(n).mean() <p>A new strategy needs to extend <code>Strategy</code> class and override its two abstract methods: <code>init()</code> and <code>next()</code>.</p> <p>Method <code>init()</code> is invoked before the strategy is run. Within it, one ideally precomputes in efficient, vectorized manner whatever indicators and signals the strategy depends on.</p> <p>Method <code>next()</code> is then iteratively called by the <code>Backtest</code> instance, once for each data point (data frame row), simulating the incremental availability of each new full candlestick bar.</p> <p>Note, backtesting.py cannot make decisions / trades within candlesticks \u2014 any new orders are executed on the next candle's open (or the current candle's close if <code>trade_on_close=True</code>). If you find yourself wishing to trade within candlesticks (e.g. daytrading), you instead need to begin with more fine-grained (e.g. hourly) data.</p> In\u00a0[3]: Copied! <pre>from minitrade.backtest import Strategy\nfrom minitrade.backtest.core.lib import crossover\n\n\nclass SmaCross(Strategy):\n    # Define the two MA lags as *class variables*\n    # for later optimization\n    n1 = 10\n    n2 = 20\n    \n    def init(self):\n        # Precompute the two moving averages\n        self.sma1 = self.I(SMA, self.data.Close.df, self.n1)\n        self.sma2 = self.I(SMA, self.data.Close.df, self.n2)\n    \n    def next(self):\n        # If sma1 crosses above sma2, close any existing\n        # short trades, and buy the asset\n        if crossover(self.sma1, self.sma2):\n            self.position().close()\n            self.buy()\n\n        # Else, if sma1 crosses below sma2, close any existing\n        # long trades, and sell the asset\n        elif crossover(self.sma2, self.sma1):\n            self.position().close()\n            self.sell()\n</pre> from minitrade.backtest import Strategy from minitrade.backtest.core.lib import crossover   class SmaCross(Strategy):     # Define the two MA lags as *class variables*     # for later optimization     n1 = 10     n2 = 20          def init(self):         # Precompute the two moving averages         self.sma1 = self.I(SMA, self.data.Close.df, self.n1)         self.sma2 = self.I(SMA, self.data.Close.df, self.n2)          def next(self):         # If sma1 crosses above sma2, close any existing         # short trades, and buy the asset         if crossover(self.sma1, self.sma2):             self.position().close()             self.buy()          # Else, if sma1 crosses below sma2, close any existing         # long trades, and sell the asset         elif crossover(self.sma2, self.sma1):             self.position().close()             self.sell() <p>In <code>init()</code> as well as in <code>next()</code>, the data the strategy is simulated on is available as an instance variable <code>self.data</code>.</p> <p>In <code>init()</code>, we declare and compute indicators indirectly by wrapping them in <code>self.I()</code>. The wrapper is passed a function (our <code>SMA</code> function) along with any arguments to call it with (our close values and the MA lag). Indicators wrapped in this way will be automatically plotted, and their legend strings will be intelligently inferred.</p> <p>In <code>next()</code>, we simply check if the faster moving average just crossed over the slower one. If it did and upwards, we close the possible short position and go long; if it did and downwards, we close the open long position and go short. Note, we don't adjust order size, so Backtesting.py assumes maximal possible position. We use <code>backtesting.lib.crossover()</code> function instead of writing more obscure and confusing conditions, such as:</p> In\u00a0[4]: Copied! <pre>%%script echo\n\n    def next(self):\n        if (self.sma1[-2] &lt; self.sma2[-2] and\n                self.sma1[-1] &gt; self.sma2[-1]):\n            self.position().close()\n            self.buy()\n\n        elif (self.sma1[-2] &gt; self.sma2[-2] and    # Ugh!\n              self.sma1[-1] &lt; self.sma2[-1]):\n            self.position().close()\n            self.sell()\n</pre> %%script echo      def next(self):         if (self.sma1[-2] &lt; self.sma2[-2] and                 self.sma1[-1] &gt; self.sma2[-1]):             self.position().close()             self.buy()          elif (self.sma1[-2] &gt; self.sma2[-2] and    # Ugh!               self.sma1[-1] &lt; self.sma2[-1]):             self.position().close()             self.sell() <pre>\n</pre> <p>In <code>init()</code>, the whole series of points was available, whereas in <code>next()</code>, the length of <code>self.data</code> and all declared indicators is adjusted on each <code>next()</code> call so that <code>array[-1]</code> (e.g. <code>self.data.Close[-1]</code> or <code>self.sma1[-1]</code>) always contains the most recent value, <code>array[-2]</code> the previous value, etc. (ordinary Python indexing of ascending-sorted 1D arrays).</p> <p>Note: <code>self.data</code> and any indicators wrapped with <code>self.I</code> (e.g. <code>self.sma1</code>) are NumPy arrays for performance reasons. If you prefer pandas Series or DataFrame objects, use <code>Strategy.data.&lt;column&gt;.s</code> or <code>Strategy.data.df</code> accessors respectively. You could also construct the series manually, e.g. <code>pd.Series(self.data.Close, index=self.data.index)</code>.</p> <p>We might avoid <code>self.position.close()</code> calls if we primed the <code>Backtest</code> instance with <code>Backtest(..., exclusive_orders=True)</code>.</p> In\u00a0[5]: Copied! <pre>from minitrade.backtest import Backtest\n\nbt = Backtest(GOOG, SmaCross, cash=10_000, commission=.002)\nstats = bt.run()\nstats\n</pre> from minitrade.backtest import Backtest  bt = Backtest(GOOG, SmaCross, cash=10_000, commission=.002) stats = bt.run() stats Out[5]: <pre>Start                                                   2004-08-19 00:00:00\nEnd                                                     2013-03-01 00:00:00\nDuration                                                 3116 days 00:00:00\nExposure Time [%]                                                 97.067039\nEquity Final [$]                                                68935.11986\nEquity Peak [$]                                                 68991.21986\nReturn [%]                                                       589.351199\nBuy &amp; Hold Return [%]                                            607.370361\nReturn (Ann.) [%]                                                 25.673113\nVolatility (Ann.) [%]                                              38.68591\nSharpe Ratio                                                        0.66363\nSortino Ratio                                                      1.303752\nCalmar Ratio                                                       0.776041\nMax. Drawdown [%]                                                -33.082172\nAvg. Drawdown [%]                                                 -5.581506\nMax. Drawdown Duration                                    688 days 00:00:00\nAvg. Drawdown Duration                                     41 days 00:00:00\n# Trades                                                                 94\nWin Rate [%]                                                      54.255319\nBest Trade [%]                                                     57.11931\nWorst Trade [%]                                                  -16.629898\nAvg. Trade [%]                                                     2.085687\nMax. Trade Duration                                       121 days 00:00:00\nAvg. Trade Duration                                        33 days 00:00:00\nProfit Factor                                                        2.1966\nExpectancy [%]                                                     2.618979\nSQN                                                                2.001593\nKelly Criterion                                                    0.259164\n_strategy                                                          SmaCross\n_equity_curve                              Equity     Asset         Cash...\n_trades                       EntryBar  ExitBar Ticker  Size  EntryPrice...\n_orders                              Ticker  Side  Size\nSignalTime      ...\n_positions                                       {'Asset': 85, 'Cash': 408}\n_trade_start_bar                                                         19\ndtype: object</pre> <p><code>Backtest.run()</code> method returns a pandas Series of simulation results and statistics associated with our strategy. We see that this simple strategy makes almost 600% return in the period of 9 years, with maximum drawdown 33%, and with longest drawdown period spanning almost two years ...</p> <p><code>Backtest.plot()</code> method provides the same insights in a more visual form.</p> In\u00a0[6]: Copied! <pre>bt.plot()\n</pre> bt.plot() <pre>/Users/ww/workspace/minitrade/minitrade/backtest/core/_plotting.py:737: UserWarning: found multiple competing values for 'toolbar.active_drag' property; using the latest value\n  fig = gridplot(\n/Users/ww/workspace/minitrade/minitrade/backtest/core/_plotting.py:737: UserWarning: found multiple competing values for 'toolbar.active_scroll' property; using the latest value\n  fig = gridplot(\n</pre> Out[6]: GridPlot(id\u00a0=\u00a0'p1342', \u2026)align\u00a0=\u00a0'auto',aspect_ratio\u00a0=\u00a0None,children\u00a0=\u00a0[(figure(id='p1046', ...), 0, 0), (figure(id='p1155', ...), 1, 0), (figure(id='p1002', ...), 2, 0), (figure(id='p1240', ...), 3, 0), (figure(id='p1285', ...), 4, 0)],cols\u00a0=\u00a0None,context_menu\u00a0=\u00a0None,css_classes\u00a0=\u00a0[],disabled\u00a0=\u00a0False,flow_mode\u00a0=\u00a0'block',height\u00a0=\u00a0None,height_policy\u00a0=\u00a0'auto',js_event_callbacks\u00a0=\u00a0{},js_property_callbacks\u00a0=\u00a0{},margin\u00a0=\u00a0None,max_height\u00a0=\u00a0None,max_width\u00a0=\u00a0None,min_height\u00a0=\u00a0None,min_width\u00a0=\u00a0None,name\u00a0=\u00a0None,resizable\u00a0=\u00a0False,rows\u00a0=\u00a0None,sizing_mode\u00a0=\u00a0'stretch_width',spacing\u00a0=\u00a00,styles\u00a0=\u00a0{},stylesheets\u00a0=\u00a0[],subscribed_events\u00a0=\u00a0PropertyValueSet(),syncable\u00a0=\u00a0True,tags\u00a0=\u00a0[],toolbar\u00a0=\u00a0Toolbar(id='p1341', ...),toolbar_location\u00a0=\u00a0'right',visible\u00a0=\u00a0True,width\u00a0=\u00a0None,width_policy\u00a0=\u00a0'auto') In\u00a0[7]: Copied! <pre>%%time\n\nstats = bt.optimize(n1=range(5, 30, 5),\n                    n2=range(10, 70, 5),\n                    maximize='Equity Final [$]',\n                    constraint=lambda param: param.n1 &lt; param.n2)\nstats\n</pre> %%time  stats = bt.optimize(n1=range(5, 30, 5),                     n2=range(10, 70, 5),                     maximize='Equity Final [$]',                     constraint=lambda param: param.n1 &lt; param.n2) stats <pre>/Users/ww/workspace/minitrade/minitrade/backtest/core/backtesting.py:2248: UserWarning: For multiprocessing support in `Backtest.optimize()` set multiprocessing start method to 'fork'.\n  warnings.warn(\"For multiprocessing support in `Backtest.optimize()` \"\n</pre> <pre>  0%|          | 0/9 [00:00&lt;?, ?it/s]</pre> <pre>CPU times: user 1.74 s, sys: 27.1 ms, total: 1.77 s\nWall time: 1.79 s\n</pre> Out[7]: <pre>Start                                                   2004-08-19 00:00:00\nEnd                                                     2013-03-01 00:00:00\nDuration                                                 3116 days 00:00:00\nExposure Time [%]                                                 99.068901\nEquity Final [$]                                               105040.12612\nEquity Peak [$]                                                108327.71798\nReturn [%]                                                       950.401261\nBuy &amp; Hold Return [%]                                            687.987489\nReturn (Ann.) [%]                                                 32.010932\nVolatility (Ann.) [%]                                             45.029728\nSharpe Ratio                                                       0.710884\nSortino Ratio                                                      1.504932\nCalmar Ratio                                                       0.727597\nMax. Drawdown [%]                                                -43.995445\nAvg. Drawdown [%]                                                 -6.138853\nMax. Drawdown Duration                                    690 days 00:00:00\nAvg. Drawdown Duration                                     43 days 00:00:00\n# Trades                                                                153\nWin Rate [%]                                                      51.633987\nBest Trade [%]                                                    61.562908\nWorst Trade [%]                                                  -19.778312\nAvg. Trade [%]                                                     1.557227\nMax. Trade Duration                                        83 days 00:00:00\nAvg. Trade Duration                                        21 days 00:00:00\nProfit Factor                                                      1.988207\nExpectancy [%]                                                     1.987172\nSQN                                                                1.619735\nKelly Criterion                                                    0.166257\n_strategy                                             SmaCross(n1=10,n2=15)\n_equity_curve                               Equity     Asset         Cas...\n_trades                        EntryBar  ExitBar Ticker  Size  EntryPric...\n_orders                              Ticker  Side  Size\nSignalTime      ...\n_positions                                      {'Asset': 130, 'Cash': 235}\n_trade_start_bar                                                         14\ndtype: object</pre> <p>We can look into <code>stats['_strategy']</code> to access the Strategy instance and its optimal parameter values (10 and 15).</p> In\u00a0[8]: Copied! <pre>stats._strategy\n</pre> stats._strategy Out[8]: <pre>&lt;Strategy SmaCross(n1=10,n2=15)&gt;</pre> In\u00a0[9]: Copied! <pre>bt.plot(plot_volume=False, plot_pl=False)\n</pre> bt.plot(plot_volume=False, plot_pl=False) <pre>/Users/ww/workspace/minitrade/minitrade/backtest/core/_plotting.py:737: UserWarning: found multiple competing values for 'toolbar.active_drag' property; using the latest value\n  fig = gridplot(\n/Users/ww/workspace/minitrade/minitrade/backtest/core/_plotting.py:737: UserWarning: found multiple competing values for 'toolbar.active_scroll' property; using the latest value\n  fig = gridplot(\n</pre> Out[9]: GridPlot(id\u00a0=\u00a0'p1653', \u2026)align\u00a0=\u00a0'auto',aspect_ratio\u00a0=\u00a0None,children\u00a0=\u00a0[(figure(id='p1413', ...), 0, 0), (figure(id='p1369', ...), 1, 0), (figure(id='p1551', ...), 2, 0), (figure(id='p1596', ...), 3, 0)],cols\u00a0=\u00a0None,context_menu\u00a0=\u00a0None,css_classes\u00a0=\u00a0[],disabled\u00a0=\u00a0False,flow_mode\u00a0=\u00a0'block',height\u00a0=\u00a0None,height_policy\u00a0=\u00a0'auto',js_event_callbacks\u00a0=\u00a0{},js_property_callbacks\u00a0=\u00a0{},margin\u00a0=\u00a0None,max_height\u00a0=\u00a0None,max_width\u00a0=\u00a0None,min_height\u00a0=\u00a0None,min_width\u00a0=\u00a0None,name\u00a0=\u00a0None,resizable\u00a0=\u00a0False,rows\u00a0=\u00a0None,sizing_mode\u00a0=\u00a0'stretch_width',spacing\u00a0=\u00a00,styles\u00a0=\u00a0{},stylesheets\u00a0=\u00a0[],subscribed_events\u00a0=\u00a0PropertyValueSet(),syncable\u00a0=\u00a0True,tags\u00a0=\u00a0[],toolbar\u00a0=\u00a0Toolbar(id='p1652', ...),toolbar_location\u00a0=\u00a0'right',visible\u00a0=\u00a0True,width\u00a0=\u00a0None,width_policy\u00a0=\u00a0'auto') <p>Strategy optimization managed to up its initial performance on in-sample data by almost 50% and even beat simple buy &amp; hold. In real life optimization, however, do take steps to avoid overfitting.</p> In\u00a0[10]: Copied! <pre>stats.tail()\n</pre> stats.tail() Out[10]: <pre>_equity_curve                         Equity     Asset         Cas...\n_trades                  EntryBar  ExitBar Ticker  Size  EntryPric...\n_orders                        Ticker  Side  Size\nSignalTime      ...\n_positions                                {'Asset': 130, 'Cash': 235}\n_trade_start_bar                                                   14\ndtype: object</pre> <p>The columns should be self-explanatory.</p> In\u00a0[11]: Copied! <pre>stats['_equity_curve']  # Contains equity/drawdown curves. DrawdownDuration is only defined at ends of DD periods.\n</pre> stats['_equity_curve']  # Contains equity/drawdown curves. DrawdownDuration is only defined at ends of DD periods. Out[11]: Equity Asset Cash DrawdownPct DrawdownDuration 2004-08-19 10000.00000 0.0 10000.00000 0.000000 NaT 2004-08-20 10000.00000 0.0 10000.00000 0.000000 NaT 2004-08-23 10000.00000 0.0 10000.00000 0.000000 NaT 2004-08-24 10000.00000 0.0 10000.00000 0.000000 NaT 2004-08-25 10000.00000 0.0 10000.00000 0.000000 NaT ... ... ... ... ... ... 2013-02-25 103035.52612 102800.1 235.42612 0.048854 NaT 2013-02-26 102952.32612 102716.9 235.42612 0.049622 NaT 2013-02-27 104206.82612 103971.4 235.42612 0.038041 NaT 2013-02-28 104391.42612 104156.0 235.42612 0.036337 NaT 2013-03-01 105040.12612 104804.7 235.42612 0.030349 533 days <p>2148 rows \u00d7 5 columns</p> In\u00a0[12]: Copied! <pre>stats['_trades']  # Contains individual trade data\n</pre> stats['_trades']  # Contains individual trade data Out[12]: EntryBar ExitBar Ticker Size EntryPrice ExitPrice PnL ReturnPct EntryTime ExitTime Tag Duration 0 20 60 Asset 87 114.64884 185.23 6140.56092 0.615629 2004-09-17 2004-11-12 None 56 days 1 60 69 Asset -87 184.85954 175.80 788.17998 0.049008 2004-11-12 2004-11-26 None 14 days 2 69 71 Asset 96 176.15160 180.71 437.60640 0.025878 2004-11-26 2004-11-30 None 4 days 3 71 75 Asset -96 180.34858 179.13 116.98368 0.006757 2004-11-30 2004-12-06 None 6 days 4 75 82 Asset 97 179.48826 177.99 -145.33122 -0.008347 2004-12-06 2004-12-15 None 9 days ... ... ... ... ... ... ... ... ... ... ... ... ... 148 2085 2111 Asset 139 689.15556 735.54 6447.43716 0.067306 2012-11-29 2013-01-08 None 40 days 149 2111 2113 Asset -139 734.06892 742.83 -1217.79012 -0.011935 2013-01-08 2013-01-10 None 2 days 150 2113 2121 Asset 136 744.31566 735.99 -1132.28976 -0.011186 2013-01-10 2013-01-23 None 13 days 151 2121 2127 Asset -136 734.51802 750.51 -2174.90928 -0.021772 2013-01-23 2013-01-31 None 8 days 152 2127 2147 Asset 130 752.01102 806.19 7043.26740 0.072045 2013-01-31 2013-03-01 None 29 days <p>153 rows \u00d7 12 columns</p> <p>Learn more by exploring further examples or find more framework options in the full API reference.</p>"},{"location":"examples/Quick%20Start%20User%20Guide/#backtestingpy-quick-start-user-guide","title":"Backtesting.py Quick Start User Guide\u00b6","text":"<p>This tutorial shows some of the features of backtesting.py, a Python framework for backtesting trading strategies.</p> <p>Backtesting.py is a small and lightweight, blazing fast backtesting framework that uses state-of-the-art Python structures and procedures (Python 3.6+, Pandas, NumPy, Bokeh). It has a very small and simple API that is easy to remember and quickly shape towards meaningful results. The library doesn't really support stock picking or trading strategies that rely on arbitrage or multi-asset portfolio rebalancing; instead, it works with an individual tradeable asset at a time and is best suited for optimizing position entrance and exit signal strategies, decisions upon values of technical indicators, and it's also a versatile interactive trade visualization and statistics tool.</p>"},{"location":"examples/Quick%20Start%20User%20Guide/#data","title":"Data\u00b6","text":"<p>You bring your own data. Backtesting ingests all kinds of OHLC data (stocks, forex, futures, crypto, ...) as a pandas.DataFrame with columns <code>'Open'</code>, <code>'High'</code>, <code>'Low'</code>, <code>'Close'</code> and (optionally) <code>'Volume'</code>. Such data is widely obtainable, e.g. with packages:</p> <ul> <li>pandas-datareader,</li> <li>Quandl,</li> <li>findatapy,</li> <li>yFinance,</li> <li>investpy, etc.</li> </ul> <p>Besides these columns, your data frames can have additional columns which are accessible in your strategies in a similar manner.</p> <p>DataFrame should ideally be indexed with a datetime index (convert it with <code>pd.to_datetime()</code>); otherwise a simple range index will do.</p>"},{"location":"examples/Quick%20Start%20User%20Guide/#strategy","title":"Strategy\u00b6","text":"<p>Let's create our first strategy to backtest on these Google data, a simple moving average (MA) cross-over strategy.</p> <p>Backtesting.py doesn't ship its own set of technical analysis indicators. Users favoring TA should probably refer to functions from proven indicator libraries, such as TA-Lib or Tulipy, but for this example, we can define a simple helper moving average function ourselves:</p>"},{"location":"examples/Quick%20Start%20User%20Guide/#backtesting","title":"Backtesting\u00b6","text":"<p>Let's see how our strategy performs on historical Google data. The <code>Backtest</code> instance is initialized with OHLC data and a strategy class (see API reference for additional options), and we begin with 10,000 units of cash and set broker's commission to realistic 0.2%.</p>"},{"location":"examples/Quick%20Start%20User%20Guide/#optimization","title":"Optimization\u00b6","text":"<p>We hard-coded the two lag parameters (<code>n1</code> and <code>n2</code>) into our strategy above. However, the strategy may work better with 15\u201330 or some other cross-over. We declared the parameters as optimizable by making them class variables.</p> <p>We optimize the two parameters by calling <code>Backtest.optimize()</code> method with each parameter a keyword argument pointing to its pool of possible values to test. Parameter <code>n1</code> is tested for values in range between 5 and 30 and parameter <code>n2</code> for values between 10 and 70, respectively. Some combinations of values of the two parameters are invalid, i.e. <code>n1</code> should not be larger than or equal to <code>n2</code>. We limit admissible parameter combinations with an ad hoc constraint function, which takes in the parameters and returns <code>True</code> (i.e. admissible) whenever <code>n1</code> is less than <code>n2</code>. Additionally, we search for such parameter combination that maximizes return over the observed period. We could instead choose to optimize any other key from the returned <code>stats</code> series.</p>"},{"location":"examples/Quick%20Start%20User%20Guide/#trade-data","title":"Trade data\u00b6","text":"<p>In addition to backtest statistics returned by <code>Backtest.run()</code> shown above, you can look into individual trade returns and the changing equity curve and drawdown by inspecting the last few, internal keys in the result series.</p>"},{"location":"examples/Strategies%20Library/","title":"Library of Composable Base Strategies","text":"In\u00a0[1]: Copied! <pre>from minitrade.backtest.core.test import SMA\n</pre> from minitrade.backtest.core.test import SMA <p>Part of this software distribution is <code>backtesting.lib</code> module that contains various reusable utilities for strategy development. Some of those utilities are composable base strategies we can extend and build upon.</p> <p>We import and extend two of those strategies here:</p> <ul> <li><code>SignalStrategy</code> which decides upon a single signal vector whether to buy into a position, akin to vectorized backtesting engines, and</li> <li><code>TrailingStrategy</code> which automatically trails the current price with a stop-loss order some multiple of average true range (ATR) away.</li> </ul> In\u00a0[2]: Copied! <pre>import pandas as pd\nimport pandas_ta as ta\nfrom minitrade.backtest.core.lib import SignalStrategy, TrailingStrategy\n\n\nclass SmaCross(SignalStrategy,\n               TrailingStrategy):\n    n1 = 10\n    n2 = 25\n    \n    def init(self):\n        # In init() and in next() it is important to call the\n        # super method to properly initialize the parent classes\n        super().init()\n        \n        # Precompute the two moving averages\n#         sma1 = self.I(self.data.ta.sma(self.n1))\n#         sma2 = self.I(self.data.ta.sma(self.n2))\n        sma1 = self.I(SMA, self.data.Close.df, self.n1)\n        sma2 = self.I(SMA, self.data.Close.df, self.n2)\n\n        \n        # Where sma1 crosses sma2 upwards. Diff gives us [-1,0, *1*]\n        signal = (sma1 &gt; sma2).astype(int).diff().fillna(0)\n        signal = signal.replace(-1, 0)  # Upwards/long only\n        \n        # Use 95% of available liquidity (at the time) on each order.\n        # (Leaving a value of 1. would instead buy a single share.)\n        entry_size = signal * .95\n                \n        # Set order entry sizes using the method provided by \n        # `SignalStrategy`. See the docs.\n        self.set_signal(entry_size=entry_size)\n        \n        # Set trailing stop-loss to 2x ATR using\n        # the method provided by `TrailingStrategy`\n        self.set_trailing_sl(2)\n</pre> import pandas as pd import pandas_ta as ta from minitrade.backtest.core.lib import SignalStrategy, TrailingStrategy   class SmaCross(SignalStrategy,                TrailingStrategy):     n1 = 10     n2 = 25          def init(self):         # In init() and in next() it is important to call the         # super method to properly initialize the parent classes         super().init()                  # Precompute the two moving averages #         sma1 = self.I(self.data.ta.sma(self.n1)) #         sma2 = self.I(self.data.ta.sma(self.n2))         sma1 = self.I(SMA, self.data.Close.df, self.n1)         sma2 = self.I(SMA, self.data.Close.df, self.n2)                   # Where sma1 crosses sma2 upwards. Diff gives us [-1,0, *1*]         signal = (sma1 &gt; sma2).astype(int).diff().fillna(0)         signal = signal.replace(-1, 0)  # Upwards/long only                  # Use 95% of available liquidity (at the time) on each order.         # (Leaving a value of 1. would instead buy a single share.)         entry_size = signal * .95                          # Set order entry sizes using the method provided by          # `SignalStrategy`. See the docs.         self.set_signal(entry_size=entry_size)                  # Set trailing stop-loss to 2x ATR using         # the method provided by `TrailingStrategy`         self.set_trailing_sl(2) <p>Note, since the strategies in <code>lib</code> may require their own intialization and next-tick logic, be sure to always call <code>super().init()</code> and <code>super().next()</code> in your overridden methods.</p> <p>Let's see how the example strategy fares on historical Google data.</p> In\u00a0[3]: Copied! <pre>from minitrade.backtest import Backtest\nfrom minitrade.backtest.core.test import GOOG\n\nbt = Backtest(GOOG, SmaCross, commission=.002)\n\nbt.run()\nbt.plot()\n</pre> from minitrade.backtest import Backtest from minitrade.backtest.core.test import GOOG  bt = Backtest(GOOG, SmaCross, commission=.002)  bt.run() bt.plot() <pre>/Users/ww/workspace/minitrade/minitrade/backtest/core/_plotting.py:737: UserWarning: found multiple competing values for 'toolbar.active_drag' property; using the latest value\n  fig = gridplot(\n/Users/ww/workspace/minitrade/minitrade/backtest/core/_plotting.py:737: UserWarning: found multiple competing values for 'toolbar.active_scroll' property; using the latest value\n  fig = gridplot(\n</pre> Out[3]: GridPlot(id\u00a0=\u00a0'p1387', \u2026)align\u00a0=\u00a0'auto',aspect_ratio\u00a0=\u00a0None,children\u00a0=\u00a0[(figure(id='p1046', ...), 0, 0), (figure(id='p1155', ...), 1, 0), (figure(id='p1002', ...), 2, 0), (figure(id='p1240', ...), 3, 0), (figure(id='p1285', ...), 4, 0), (figure(id='p1330', ...), 5, 0)],cols\u00a0=\u00a0None,context_menu\u00a0=\u00a0None,css_classes\u00a0=\u00a0[],disabled\u00a0=\u00a0False,flow_mode\u00a0=\u00a0'block',height\u00a0=\u00a0None,height_policy\u00a0=\u00a0'auto',js_event_callbacks\u00a0=\u00a0{},js_property_callbacks\u00a0=\u00a0{},margin\u00a0=\u00a0None,max_height\u00a0=\u00a0None,max_width\u00a0=\u00a0None,min_height\u00a0=\u00a0None,min_width\u00a0=\u00a0None,name\u00a0=\u00a0None,resizable\u00a0=\u00a0False,rows\u00a0=\u00a0None,sizing_mode\u00a0=\u00a0'stretch_width',spacing\u00a0=\u00a00,styles\u00a0=\u00a0{},stylesheets\u00a0=\u00a0[],subscribed_events\u00a0=\u00a0PropertyValueSet(),syncable\u00a0=\u00a0True,tags\u00a0=\u00a0[],toolbar\u00a0=\u00a0Toolbar(id='p1386', ...),toolbar_location\u00a0=\u00a0'right',visible\u00a0=\u00a0True,width\u00a0=\u00a0None,width_policy\u00a0=\u00a0'auto') <p>Notice how managing risk with a trailing stop-loss secures our gains and limits our losses.</p> <p>For other strategies of the sort, and other reusable utilities in general, see backtesting.lib module reference.</p> <p>Learn more by exploring further examples or find more framework options in the full API reference.</p>"},{"location":"examples/Strategies%20Library/#library-of-composable-base-strategies","title":"Library of Composable Base Strategies\u00b6","text":"<p>This tutorial will show how to reuse composable base trading strategies that are part of backtesting.py software distribution. It is, henceforth, assumed you're already familiar with basic package usage.</p> <p>We'll extend the same moving average cross-over strategy as in Quick Start User Guide, but we'll rewrite it as a vectorized signal strategy and add trailing stop-loss.</p> <p>Again, we'll use our helper moving average function.</p>"},{"location":"examples/Trading%20with%20Machine%20Learning/","title":"Trading with Machine Learning Models","text":"In\u00a0[1]: Copied! <pre>from minitrade.backtest.core.test import EURUSD, SMA\n\ndata = EURUSD.copy()\ndata\n</pre> from minitrade.backtest.core.test import EURUSD, SMA  data = EURUSD.copy() data Out[1]: Open High Low Close Volume 2017-04-19 09:00:00 1.07160 1.07220 1.07083 1.07219 1413 2017-04-19 10:00:00 1.07214 1.07296 1.07214 1.07260 1241 2017-04-19 11:00:00 1.07256 1.07299 1.07170 1.07192 1025 2017-04-19 12:00:00 1.07195 1.07280 1.07195 1.07202 1460 2017-04-19 13:00:00 1.07200 1.07230 1.07045 1.07050 1554 ... ... ... ... ... ... 2018-02-07 11:00:00 1.23390 1.23548 1.23386 1.23501 2203 2018-02-07 12:00:00 1.23501 1.23508 1.23342 1.23422 2325 2018-02-07 13:00:00 1.23422 1.23459 1.23338 1.23372 2824 2018-02-07 14:00:00 1.23374 1.23452 1.23238 1.23426 4065 2018-02-07 15:00:00 1.23427 1.23444 1.22904 1.22904 6143 <p>5000 rows \u00d7 5 columns</p> <p>In supervised machine learning, we try to learn a function that maps input feature vectors (independent variables) into known output values (dependent variable):</p> <p>$$ f\\colon X \\to \\mathbf{y} $$</p> <p>That way, provided our model function is sufficient, we can predict future output values from the newly acquired input feature vectors to some degree of certainty. In our example, we'll try to map several price-derived features and common technical indicators to the price point two days in the future. We construct model design matrix $X$ below:</p> In\u00a0[2]: Copied! <pre>def BBANDS(data, n_lookback, n_std):\n    \"\"\"Bollinger bands indicator\"\"\"\n    hlc3 = (data.High + data.Low + data.Close) / 3\n    mean, std = hlc3.rolling(n_lookback).mean(), hlc3.rolling(n_lookback).std()\n    upper = mean + n_std*std\n    lower = mean - n_std*std\n    return upper, lower\n\n\nclose = data.Close.values\nsma10 = SMA(data.Close, 10)\nsma20 = SMA(data.Close, 20)\nsma50 = SMA(data.Close, 50)\nsma100 = SMA(data.Close, 100)\nupper, lower = BBANDS(data, 20, 2)\n\n# Design matrix / independent features:\n\n# Price-derived features\ndata['X_SMA10'] = (close - sma10) / close\ndata['X_SMA20'] = (close - sma20) / close\ndata['X_SMA50'] = (close - sma50) / close\ndata['X_SMA100'] = (close - sma100) / close\n\ndata['X_DELTA_SMA10'] = (sma10 - sma20) / close\ndata['X_DELTA_SMA20'] = (sma20 - sma50) / close\ndata['X_DELTA_SMA50'] = (sma50 - sma100) / close\n\n# Indicator features\ndata['X_MOM'] = data.Close.pct_change(periods=2)\ndata['X_BB_upper'] = (upper - close) / close\ndata['X_BB_lower'] = (lower - close) / close\ndata['X_BB_width'] = (upper - lower) / close\ndata['X_Sentiment'] = ~data.index.to_series().between('2017-09-27', '2017-12-14')\n\n# Some datetime features for good measure\ndata['X_day'] = data.index.dayofweek\ndata['X_hour'] = data.index.hour\n\ndata = data.dropna().astype(float)\n</pre> def BBANDS(data, n_lookback, n_std):     \"\"\"Bollinger bands indicator\"\"\"     hlc3 = (data.High + data.Low + data.Close) / 3     mean, std = hlc3.rolling(n_lookback).mean(), hlc3.rolling(n_lookback).std()     upper = mean + n_std*std     lower = mean - n_std*std     return upper, lower   close = data.Close.values sma10 = SMA(data.Close, 10) sma20 = SMA(data.Close, 20) sma50 = SMA(data.Close, 50) sma100 = SMA(data.Close, 100) upper, lower = BBANDS(data, 20, 2)  # Design matrix / independent features:  # Price-derived features data['X_SMA10'] = (close - sma10) / close data['X_SMA20'] = (close - sma20) / close data['X_SMA50'] = (close - sma50) / close data['X_SMA100'] = (close - sma100) / close  data['X_DELTA_SMA10'] = (sma10 - sma20) / close data['X_DELTA_SMA20'] = (sma20 - sma50) / close data['X_DELTA_SMA50'] = (sma50 - sma100) / close  # Indicator features data['X_MOM'] = data.Close.pct_change(periods=2) data['X_BB_upper'] = (upper - close) / close data['X_BB_lower'] = (lower - close) / close data['X_BB_width'] = (upper - lower) / close data['X_Sentiment'] = ~data.index.to_series().between('2017-09-27', '2017-12-14')  # Some datetime features for good measure data['X_day'] = data.index.dayofweek data['X_hour'] = data.index.hour  data = data.dropna().astype(float) <p>Since all our indicators work only with past values, we can safely precompute the design matrix in advance. Alternatively, we would reconstruct the matrix every time before training the model.</p> <p>Notice the made-up sentiment feature. In real life, one would obtain similar features by parsing news sources, Twitter sentiment, Stocktwits or similar. This is just to show input data can contain all sorts of additional explanatory columns.</p> <p>As mentioned, our dependent variable will be the price (return) two days in the future, simplified into values $1$ when the return is positive (and significant), $-1$ when negative, or $0$ when the return after two days is roughly around zero. Let's write some functions that return our model matrix $X$ and dependent, class variable $\\mathbf{y}$ as plain NumPy arrays:</p> In\u00a0[3]: Copied! <pre>import numpy as np\n\n\ndef get_X(data):\n    \"\"\"Return model design matrix X\"\"\"\n    return data.filter(like='X').values\n\n\ndef get_y(data):\n    \"\"\"Return dependent variable y\"\"\"\n    y = data.Close.pct_change(48).shift(-48)  # Returns after roughly two days\n    y[y.between(-.004, .004)] = 0             # Devalue returns smaller than 0.4%\n    y[y &gt; 0] = 1\n    y[y &lt; 0] = -1\n    return y\n\n\ndef get_clean_Xy(df):\n    \"\"\"Return (X, y) cleaned of NaN values\"\"\"\n    X = get_X(df)\n    y = get_y(df).values\n    isnan = np.isnan(y)\n    X = X[~isnan]\n    y = y[~isnan]\n    return X, y\n</pre> import numpy as np   def get_X(data):     \"\"\"Return model design matrix X\"\"\"     return data.filter(like='X').values   def get_y(data):     \"\"\"Return dependent variable y\"\"\"     y = data.Close.pct_change(48).shift(-48)  # Returns after roughly two days     y[y.between(-.004, .004)] = 0             # Devalue returns smaller than 0.4%     y[y &gt; 0] = 1     y[y &lt; 0] = -1     return y   def get_clean_Xy(df):     \"\"\"Return (X, y) cleaned of NaN values\"\"\"     X = get_X(df)     y = get_y(df).values     isnan = np.isnan(y)     X = X[~isnan]     y = y[~isnan]     return X, y <p>Let's see how our data performs modeled using a simple k-nearest neighbors (kNN) algorithm from the state of the art scikit-learn Python machine learning package. To avoid (or at least demonstrate) overfitting, always split your data into train and test sets; in particular, don't validate your model performance on the same data it was built on.</p> In\u00a0[4]: Copied! <pre>import pandas as pd\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.model_selection import train_test_split\n\nX, y = get_clean_Xy(data)\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.5, random_state=0)\n\nclf = KNeighborsClassifier(7)  # Model the output based on 7 \"nearest\" examples\nclf.fit(X_train, y_train)\n\ny_pred = clf.predict(X_test)\n\n_ = pd.DataFrame({'y_true': y_test, 'y_pred': y_pred}).plot(figsize=(15, 2), alpha=.7)\nprint('Classification accuracy: ', np.mean(y_test == y_pred))\n</pre> import pandas as pd from sklearn.neighbors import KNeighborsClassifier from sklearn.model_selection import train_test_split  X, y = get_clean_Xy(data) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.5, random_state=0)  clf = KNeighborsClassifier(7)  # Model the output based on 7 \"nearest\" examples clf.fit(X_train, y_train)  y_pred = clf.predict(X_test)  _ = pd.DataFrame({'y_true': y_test, 'y_pred': y_pred}).plot(figsize=(15, 2), alpha=.7) print('Classification accuracy: ', np.mean(y_test == y_pred)) <pre>Classification accuracy:  0.4210960032962505\n</pre> <p>We see the forecasts are all over the place (classification accuracy 42%), but is the model of any use under real backtesting?</p> <p>Let's backtest a simple strategy that buys the asset for 20% of available equity with 20:1 leverage whenever the forecast is positive (the price in two days is predicted to go up), and sells under the same terms when the forecast is negative, all the while setting reasonable stop-loss and take-profit levels. Notice also the steady use of <code>data.df</code> accessor:</p> In\u00a0[5]: Copied! <pre>%%time\n\nfrom minitrade.backtest import Backtest, Strategy\n\nN_TRAIN = 400\n\n\nclass MLTrainOnceStrategy(Strategy):\n    price_delta = .004  # 0.4%\n\n    def init(self):        \n        # Init our model, a kNN classifier\n        self.clf = KNeighborsClassifier(7)\n\n        # Train the classifier in advance on the first N_TRAIN examples\n        df = self.data.df.iloc[:N_TRAIN]\n        X, y = get_clean_Xy(df)\n        self.clf.fit(X, y)\n\n        # Plot y for inspection\n        self.I(get_y, self.data.df, name='y_true')\n\n        # Prepare empty, all-NaN forecast indicator\n        self.forecasts = self.I(lambda: np.repeat(np.nan, len(self.data)), name='forecast')\n\n    def next(self):\n        # Skip the training, in-sample data\n        if len(self.data) &lt; N_TRAIN:\n            return\n\n        # Proceed only with out-of-sample data. Prepare some variables\n        high, low, close = self.data.High, self.data.Low, self.data.Close\n        current_time = self.data.index[-1]\n\n        # Forecast the next movement\n        X = get_X(self.data.df.iloc[-1:])\n        forecast = self.clf.predict(X)[0]\n\n        # Update the plotted \"forecast\" indicator\n        self.forecasts[-1] = forecast\n\n        # If our forecast is upwards and we don't already hold a long position\n        # place a long order for 20% of available account equity. Vice versa for short.\n        # Also set target take-profit and stop-loss prices to be one price_delta\n        # away from the current closing price.\n        upper, lower = close[-1] * (1 + np.r_[1, -1]*self.price_delta)\n\n        if forecast == 1 and not self.position().is_long:\n            self.buy(size=.2, tp=upper, sl=lower)\n        elif forecast == -1 and not self.position().is_short:\n            self.sell(size=.2, tp=lower, sl=upper)\n\n        # Additionally, set aggressive stop-loss on trades that have been open \n        # for more than two days\n        for trade in self.trades():\n            if current_time - trade.entry_time &gt; pd.Timedelta('2 days'):\n                if trade.is_long:\n                    trade.sl = max(trade.sl, low[-1])\n                else:\n                    trade.sl = min(trade.sl, high[-1])\n\n\nbt = Backtest(data, MLTrainOnceStrategy, commission=.0002, margin=.05)\nbt.run()\n</pre> %%time  from minitrade.backtest import Backtest, Strategy  N_TRAIN = 400   class MLTrainOnceStrategy(Strategy):     price_delta = .004  # 0.4%      def init(self):                 # Init our model, a kNN classifier         self.clf = KNeighborsClassifier(7)          # Train the classifier in advance on the first N_TRAIN examples         df = self.data.df.iloc[:N_TRAIN]         X, y = get_clean_Xy(df)         self.clf.fit(X, y)          # Plot y for inspection         self.I(get_y, self.data.df, name='y_true')          # Prepare empty, all-NaN forecast indicator         self.forecasts = self.I(lambda: np.repeat(np.nan, len(self.data)), name='forecast')      def next(self):         # Skip the training, in-sample data         if len(self.data) &lt; N_TRAIN:             return          # Proceed only with out-of-sample data. Prepare some variables         high, low, close = self.data.High, self.data.Low, self.data.Close         current_time = self.data.index[-1]          # Forecast the next movement         X = get_X(self.data.df.iloc[-1:])         forecast = self.clf.predict(X)[0]          # Update the plotted \"forecast\" indicator         self.forecasts[-1] = forecast          # If our forecast is upwards and we don't already hold a long position         # place a long order for 20% of available account equity. Vice versa for short.         # Also set target take-profit and stop-loss prices to be one price_delta         # away from the current closing price.         upper, lower = close[-1] * (1 + np.r_[1, -1]*self.price_delta)          if forecast == 1 and not self.position().is_long:             self.buy(size=.2, tp=upper, sl=lower)         elif forecast == -1 and not self.position().is_short:             self.sell(size=.2, tp=lower, sl=upper)          # Additionally, set aggressive stop-loss on trades that have been open          # for more than two days         for trade in self.trades():             if current_time - trade.entry_time &gt; pd.Timedelta('2 days'):                 if trade.is_long:                     trade.sl = max(trade.sl, low[-1])                 else:                     trade.sl = min(trade.sl, high[-1])   bt = Backtest(data, MLTrainOnceStrategy, commission=.0002, margin=.05) bt.run() <pre>CPU times: user 4.23 s, sys: 13.5 ms, total: 4.25 s\nWall time: 4.26 s\n</pre> Out[5]: <pre>Start                                                   2017-04-25 12:00:00\nEnd                                                     2018-02-07 15:00:00\nDuration                                                  288 days 03:00:00\nExposure Time [%]                                                 79.412365\nEquity Final [$]                                                  14176.625\nEquity Peak [$]                                                14979.134698\nReturn [%]                                                         41.76625\nBuy &amp; Hold Return [%]                                             12.869869\nReturn (Ann.) [%]                                                 42.978175\nVolatility (Ann.) [%]                                             26.903561\nSharpe Ratio                                                        1.59749\nSortino Ratio                                                      3.607936\nCalmar Ratio                                                       4.553512\nMax. Drawdown [%]                                                 -9.438468\nAvg. Drawdown [%]                                                 -1.105954\nMax. Drawdown Duration                                     41 days 23:00:00\nAvg. Drawdown Duration                                      2 days 15:00:00\n# Trades                                                                353\nWin Rate [%]                                                      52.691218\nBest Trade [%]                                                     0.578258\nWorst Trade [%]                                                   -0.519427\nAvg. Trade [%]                                                      0.02372\nMax. Trade Duration                                         3 days 09:00:00\nAvg. Trade Duration                                         0 days 19:00:00\nProfit Factor                                                      1.216404\nExpectancy [%]                                                     0.024147\nSQN                                                                1.850516\nKelly Criterion                                                    0.121275\n_strategy                                               MLTrainOnceStrategy\n_equity_curve                                        Equity        Asset...\n_trades                        EntryBar  ExitBar Ticker   Size  EntryPri...\n_orders                                       Ticker  Side   Size\nSignal...\n_positions                                      {'Asset': 0, 'Cash': 14176}\n_trade_start_bar                                                          0\ndtype: object</pre> In\u00a0[6]: Copied! <pre>bt.plot()\n</pre> bt.plot() <pre>/Users/ww/workspace/minitrade/minitrade/backtest/core/_plotting.py:737: UserWarning: found multiple competing values for 'toolbar.active_drag' property; using the latest value\n  fig = gridplot(\n/Users/ww/workspace/minitrade/minitrade/backtest/core/_plotting.py:737: UserWarning: found multiple competing values for 'toolbar.active_scroll' property; using the latest value\n  fig = gridplot(\n</pre> Out[6]: GridPlot(id\u00a0=\u00a0'p1342', \u2026)align\u00a0=\u00a0'auto',aspect_ratio\u00a0=\u00a0None,children\u00a0=\u00a0[(figure(id='p1046', ...), 0, 0), (figure(id='p1155', ...), 1, 0), (figure(id='p1002', ...), 2, 0), (figure(id='p1240', ...), 3, 0), (figure(id='p1285', ...), 4, 0)],cols\u00a0=\u00a0None,context_menu\u00a0=\u00a0None,css_classes\u00a0=\u00a0[],disabled\u00a0=\u00a0False,flow_mode\u00a0=\u00a0'block',height\u00a0=\u00a0None,height_policy\u00a0=\u00a0'auto',js_event_callbacks\u00a0=\u00a0{},js_property_callbacks\u00a0=\u00a0{},margin\u00a0=\u00a0None,max_height\u00a0=\u00a0None,max_width\u00a0=\u00a0None,min_height\u00a0=\u00a0None,min_width\u00a0=\u00a0None,name\u00a0=\u00a0None,resizable\u00a0=\u00a0False,rows\u00a0=\u00a0None,sizing_mode\u00a0=\u00a0'stretch_width',spacing\u00a0=\u00a00,styles\u00a0=\u00a0{},stylesheets\u00a0=\u00a0[],subscribed_events\u00a0=\u00a0PropertyValueSet(),syncable\u00a0=\u00a0True,tags\u00a0=\u00a0[],toolbar\u00a0=\u00a0Toolbar(id='p1341', ...),toolbar_location\u00a0=\u00a0'right',visible\u00a0=\u00a0True,width\u00a0=\u00a0None,width_policy\u00a0=\u00a0'auto') <p>Despite our lousy win rate, the strategy seems profitable. Let's see how it performs under walk-forward optimization, akin to k-fold or leave-one-out cross-validation:</p> In\u00a0[7]: Copied! <pre>%%time\n\nclass MLWalkForwardStrategy(MLTrainOnceStrategy):\n    def next(self):\n        # Skip the cold start period with too few values available\n        if len(self.data) &lt; N_TRAIN:\n            return\n\n        # Re-train the model only every 20 iterations.\n        # Since 20 &lt;&lt; N_TRAIN, we don't lose much in terms of\n        # \"recent training examples\", but the speed-up is significant!\n        if len(self.data) % 20:\n            return super().next()\n\n        # Retrain on last N_TRAIN values\n        df = self.data.df.iloc[-N_TRAIN:]\n        X, y = get_clean_Xy(df)\n        self.clf.fit(X, y)\n\n        # Now that the model is fitted, \n        # proceed the same as in MLTrainOnceStrategy\n        super().next()\n\n\nbt = Backtest(data, MLWalkForwardStrategy, commission=.0002, margin=.05)\nbt.run()\n</pre> %%time  class MLWalkForwardStrategy(MLTrainOnceStrategy):     def next(self):         # Skip the cold start period with too few values available         if len(self.data) &lt; N_TRAIN:             return          # Re-train the model only every 20 iterations.         # Since 20 &lt;&lt; N_TRAIN, we don't lose much in terms of         # \"recent training examples\", but the speed-up is significant!         if len(self.data) % 20:             return super().next()          # Retrain on last N_TRAIN values         df = self.data.df.iloc[-N_TRAIN:]         X, y = get_clean_Xy(df)         self.clf.fit(X, y)          # Now that the model is fitted,          # proceed the same as in MLTrainOnceStrategy         super().next()   bt = Backtest(data, MLWalkForwardStrategy, commission=.0002, margin=.05) bt.run() <pre>CPU times: user 4.6 s, sys: 30.3 ms, total: 4.63 s\nWall time: 4.64 s\n</pre> Out[7]: <pre>Start                                                   2017-04-25 12:00:00\nEnd                                                     2018-02-07 15:00:00\nDuration                                                  288 days 03:00:00\nExposure Time [%]                                                 71.720057\nEquity Final [$]                                                5885.371145\nEquity Peak [$]                                                10052.843539\nReturn [%]                                                       -41.146289\nBuy &amp; Hold Return [%]                                             12.869869\nReturn (Ann.) [%]                                                -41.902348\nVolatility (Ann.) [%]                                             10.794943\nSharpe Ratio                                                      -3.881664\nSortino Ratio                                                     -2.803659\nCalmar Ratio                                                      -1.010398\nMax. Drawdown [%]                                                -41.471113\nAvg. Drawdown [%]                                                -14.356287\nMax. Drawdown Duration                                    261 days 18:00:00\nAvg. Drawdown Duration                                     88 days 05:00:00\n# Trades                                                                324\nWin Rate [%]                                                      41.666667\nBest Trade [%]                                                     0.384255\nWorst Trade [%]                                                   -0.506643\nAvg. Trade [%]                                                    -0.048462\nMax. Trade Duration                                         3 days 07:00:00\nAvg. Trade Duration                                         0 days 18:00:00\nProfit Factor                                                      0.673567\nExpectancy [%]                                                     -0.04804\nSQN                                                               -2.792099\nKelly Criterion                                                   -0.212186\n_strategy                                             MLWalkForwardStrategy\n_equity_curve                                        Equity  Asset      ...\n_trades                        EntryBar  ExitBar Ticker   Size  EntryPri...\n_orders                                       Ticker  Side   Size\nSignal...\n_positions                                       {'Asset': 0, 'Cash': 5885}\n_trade_start_bar                                                          0\ndtype: object</pre> In\u00a0[8]: Copied! <pre>bt.plot()\n</pre> bt.plot() <pre>/Users/ww/workspace/minitrade/minitrade/backtest/core/_plotting.py:737: UserWarning: found multiple competing values for 'toolbar.active_drag' property; using the latest value\n  fig = gridplot(\n/Users/ww/workspace/minitrade/minitrade/backtest/core/_plotting.py:737: UserWarning: found multiple competing values for 'toolbar.active_scroll' property; using the latest value\n  fig = gridplot(\n</pre> Out[8]: GridPlot(id\u00a0=\u00a0'p1710', \u2026)align\u00a0=\u00a0'auto',aspect_ratio\u00a0=\u00a0None,children\u00a0=\u00a0[(figure(id='p1413', ...), 0, 0), (figure(id='p1522', ...), 1, 0), (figure(id='p1369', ...), 2, 0), (figure(id='p1607', ...), 3, 0), (figure(id='p1652', ...), 4, 0)],cols\u00a0=\u00a0None,context_menu\u00a0=\u00a0None,css_classes\u00a0=\u00a0[],disabled\u00a0=\u00a0False,flow_mode\u00a0=\u00a0'block',height\u00a0=\u00a0None,height_policy\u00a0=\u00a0'auto',js_event_callbacks\u00a0=\u00a0{},js_property_callbacks\u00a0=\u00a0{},margin\u00a0=\u00a0None,max_height\u00a0=\u00a0None,max_width\u00a0=\u00a0None,min_height\u00a0=\u00a0None,min_width\u00a0=\u00a0None,name\u00a0=\u00a0None,resizable\u00a0=\u00a0False,rows\u00a0=\u00a0None,sizing_mode\u00a0=\u00a0'stretch_width',spacing\u00a0=\u00a00,styles\u00a0=\u00a0{},stylesheets\u00a0=\u00a0[],subscribed_events\u00a0=\u00a0PropertyValueSet(),syncable\u00a0=\u00a0True,tags\u00a0=\u00a0[],toolbar\u00a0=\u00a0Toolbar(id='p1709', ...),toolbar_location\u00a0=\u00a0'right',visible\u00a0=\u00a0True,width\u00a0=\u00a0None,width_policy\u00a0=\u00a0'auto') <p>Apparently, when repeatedly retrained on past <code>N_TRAIN</code> data points in a rolling manner, our basic model generalizes poorly and performs not quite as well.</p> <p>This was a simple and contrived, tongue-in-cheek example that shows one way to use machine learning forecast models with backtesting.py framework. In reality, you will need a far better feature space, better models (cf. deep learning), and better money management strategies to achieve consistent profits in automated short-term forex trading. More proper data science is an exercise for the keen reader.</p> <p>Some instant optimization tips that come to mind are:</p> <ul> <li>Data is king. Make sure your design matrix features as best as possible model and correlate with your chosen target variable(s) and not just represent random noise.</li> <li>Instead of modelling a single target variable $y$, model a multitude of target/class variables, possibly better designed than our \"48-hour returns\" above.</li> <li>Model everything: forecast price, volume, time before it \"takes off\", SL/TP levels, optimal position size ...</li> <li>Reduce false positives by increasing the conviction needed and imposing extra domain expertise and discretionary limitations before entering trades.</li> </ul> <p>Also make sure to familiarize yourself with the full Backtesting.py API reference</p>"},{"location":"examples/Trading%20with%20Machine%20Learning/#trading-with-machine-learning-models","title":"Trading with Machine Learning Models\u00b6","text":"<p>This tutorial will show how to train and backtest a machine learning price forecast model with backtesting.py framework. It is assumed you're already familiar with basic framework usage and machine learning in general.</p> <p>For this tutorial, we'll use almost a year's worth sample of hourly EUR/USD forex data:</p>"}]}